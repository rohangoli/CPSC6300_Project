"""<STR_LIT>""" <EOL> import sys <EOL> from sys import stdin <EOL> input = stdin . readline <EOL> class Point ( object ) : <EOL> epsilon = <NUM_LIT> <EOL> def __init__ ( self , x = <NUM_LIT:0.0> , y = <NUM_LIT:0.0> ) : <EOL> if isinstance ( x , tuple ) : <EOL> self . x = x [ <NUM_LIT:0> ] <EOL> self . y = x [ <NUM_LIT:1> ] <EOL> else : <EOL> self . x = x <EOL> self . y = y <EOL> def __add__ ( self , other ) : <EOL> return Point ( self . x + other . x , self . y + other . y ) <EOL> def __sub__ ( self , other ) : <EOL> return Point ( self . x - other . x , self . y - other . y ) <EOL> def __mul__ ( self , other ) : <EOL> return Point ( other * self . x , other * self . y ) <EOL> def __truediv__ ( self , other ) : <EOL> return Point ( self . x / other , self . y / other ) <EOL> def __lt__ ( self , other ) : <EOL> if self . x == other . x : <EOL> return self . y < other . y <EOL> else : <EOL> return self . x < other . x <EOL> def __eq__ ( self , other ) : <EOL> from math import fabs <EOL> if fabs ( self . x - other . x ) < Point . epsilon and fabs ( self . y - other . y ) < Point . epsilon : <EOL> return True <EOL> else : <EOL> return False <EOL> def norm ( self ) : <EOL> return self . x * self . x + self . y * self . y <EOL> def __abs__ ( self ) : <EOL> return sqrt ( self . norm ( ) ) <EOL> def ccw ( self , p0 , p1 ) : <EOL> a = Vector ( p1 - p0 ) <EOL> b = Vector ( self - p0 ) <EOL> if Vector . cross ( a , b ) > Point . epsilon : <EOL> return <NUM_LIT:1> <EOL> elif Vector . cross ( a , b ) < - Point . epsilon : <EOL> return - <NUM_LIT:1> <EOL> elif Vector . dot ( a , b ) < - Point . epsilon : <EOL> return <NUM_LIT:2> <EOL> elif a . norm ( ) < b . norm ( ) : <EOL> return - <NUM_LIT:2> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> def project ( self , s ) : <EOL> base = Vector ( s . p2 - s . p1 ) <EOL> a = Vector ( self - s . p1 ) <EOL> r = Vector . dot ( a , base ) <EOL> r /= base . norm ( ) <EOL> return s . p1 + base * r <EOL> def reflect ( self , s ) : <EOL> proj = self . project ( s ) <EOL> return self + ( proj - self ) * <NUM_LIT:2> <EOL> def distance ( self , s ) : <EOL> if Vector . dot ( s . p2 - s . p1 , self - s . p1 ) < <NUM_LIT:0.0> : <EOL> return abs ( self - s . p1 ) <EOL> if Vector . dot ( s . p1 - s . p2 , self - s . p2 ) < <NUM_LIT:0.0> : <EOL> return abs ( self - s . p2 ) <EOL> return abs ( Vector . cross ( s . p2 - s . p1 , self - s . p1 ) / abs ( s . p2 - s . p1 ) ) <EOL> class Vector ( Point ) : <EOL> def __init__ ( self , x = <NUM_LIT:0.0> , y = <NUM_LIT:0.0> ) : <EOL> if isinstance ( x , tuple ) : <EOL> self . x = x [ <NUM_LIT:0> ] <EOL> self . y = x [ <NUM_LIT:1> ] <EOL> elif isinstance ( x , Point ) : <EOL> self . x = x . x <EOL> self . y = x . y <EOL> else : <EOL> self . x = x <EOL> self . y = y <EOL> def __add__ ( self , other ) : <EOL> return Vector ( self . x + other . x , self . y + other . y ) <EOL> def __sub__ ( self , other ) : <EOL> return Vector ( self . x - other . x , self . y - other . y ) <EOL> def __mul__ ( self , other ) : <EOL> return Vector ( other * self . x , other * self . y ) <EOL> def __truediv__ ( self , other ) : <EOL> return Vector ( self . x / other , self . y / other ) <EOL> @ classmethod <EOL> def dot ( cls , a , b ) : <EOL> return a . x * b . x + a . y * b . y <EOL> @ classmethod <EOL> def cross ( cls , a , b ) : <EOL> return a . x * b . y - a . y * b . x <EOL> @ classmethod <EOL> def is_orthogonal ( cls , a , b ) : <EOL> return Vector . dot ( a , b ) == <NUM_LIT:0.0> <EOL> @ classmethod <EOL> def is_parallel ( cls , a , b ) : <EOL> return Vector . cross ( a , b ) == <NUM_LIT:0.0> <EOL> class Segment ( object ) : <EOL> def __init__ ( self , p1 = Point ( ) , p2 = Point ( ) ) : <EOL> if isinstance ( p1 , Point ) : <EOL> self . p1 = p1 <EOL> self . p2 = p2 <EOL> elif isinstance ( p1 , tuple ) : <EOL> self . p1 = Point ( p1 [ <NUM_LIT:0> ] , p1 [ <NUM_LIT:1> ] ) <EOL> self . p2 = Point ( p2 [ <NUM_LIT:0> ] , p2 [ <NUM_LIT:1> ] ) <EOL> def intersect ( self , s ) : <EOL> ans1 = s . p1 . ccw ( self . p1 , self . p2 ) * s . p2 . ccw ( self . p1 , self . p2 ) <EOL> ans2 = self . p1 . ccw ( s . p1 , s . p2 ) * self . p2 . ccw ( s . p1 , s . p2 ) <EOL> return ans1 <= <NUM_LIT:0> and ans2 <= <NUM_LIT:0> <EOL> def cross_point ( self , s ) : <EOL> base = s . p2 - s . p1 <EOL> d1 = abs ( Vector . cross ( base , self . p1 - s . p1 ) ) <EOL> d2 = abs ( Vector . cross ( base , self . p2 - s . p1 ) ) <EOL> t = d1 / ( d1 + d2 ) <EOL> return self . p1 + ( self . p2 - self . p1 ) * t <EOL> def distance ( self , s ) : <EOL> if self . intersect ( s ) : <EOL> return <NUM_LIT:0.0> <EOL> d1 = s . p1 . distance ( self ) <EOL> d2 = s . p2 . distance ( self ) <EOL> d3 = self . p1 . distance ( s ) <EOL> d4 = self . p2 . distance ( s ) <EOL> return min ( d1 , d2 , d3 , d4 ) <EOL> @ classmethod <EOL> def is_orthogonal ( cls , s1 , s2 ) : <EOL> a = Vector ( s1 . p2 - s1 . p1 ) <EOL> b = Vector ( s2 . p2 - s2 . p1 ) <EOL> return Vector . is_orthogonal ( a , b ) <EOL> @ classmethod <EOL> def is_parallel ( cls , s1 , s2 ) : <EOL> a = Vector ( s1 . p2 - s1 . p1 ) <EOL> b = Vector ( s2 . p2 - s2 . p1 ) <EOL> return Vector . is_parallel ( a , b ) <EOL> class Line ( Segment ) : <EOL> pass <EOL> class Cirle ( object ) : <EOL> def __init__ ( self , x , y = Point ( ) , r = <NUM_LIT:1.0> ) : <EOL> if isinstance ( x , Point ) : <EOL> self . c = x <EOL> self . r = y <EOL> elif isinstance ( x , tuple ) : <EOL> self . c = Point ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] ) <EOL> self . r = r <EOL> def cross_points ( self , s ) : <EOL> if isinstance ( s , Segment ) : <EOL> pr = self . c . project ( s ) <EOL> e = ( s . p2 - s . p1 ) / abs ( s . p2 - s . p1 ) <EOL> base = sqrt ( self . r * self . r - ( pr - self . c ) . norm ( ) ) <EOL> return pr + e * base , pr - e * base <EOL> elif isinstance ( s , Cirle ) : <EOL> c2 = s <EOL> d = abs ( self . c - c2 . c ) <EOL> a = acos ( ( self . r * self . r + d * d - c2 . r * c2 . r ) / ( <NUM_LIT:2> * self . r * d ) ) <EOL> t = atan2 ( c2 . c . y - self . c . y , c2 . c . x - self . c . x ) <EOL> temp1 = Point ( cos ( t + a ) * self . r , sin ( t + a ) * self . r ) <EOL> temp2 = Point ( cos ( t - a ) * self . r , sin ( t - a ) * self . r ) <EOL> return self . c + temp1 , self . c + temp2 <EOL> def contains ( polygon , p ) : <EOL> n = len ( polygon ) <EOL> x = False <EOL> for i in range ( n ) : <EOL> a = polygon [ i ] - p <EOL> b = polygon [ ( i + <NUM_LIT:1> ) % n ] - p <EOL> if abs ( Vector . cross ( a , b ) ) < Point . epsilon and Vector . dot ( a , b ) < Point . epsilon : <EOL> return <NUM_LIT:1> <EOL> if a . y > b . y : <EOL> temp = a <EOL> a = b <EOL> b = temp <EOL> if a . y < Point . epsilon and Point . epsilon < b . y and Vector . cross ( a , b ) > Point . epsilon : <EOL> x = not x <EOL> return <NUM_LIT:2> if x else <NUM_LIT:0> <EOL> def main ( args ) : <EOL> for line in sys . stdin : <EOL> polygon = [ ] <EOL> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , line . split ( ) ) <EOL> polygon . append ( Point ( x1 , y1 ) ) <EOL> polygon . append ( Point ( x2 , y2 ) ) <EOL> polygon . append ( Point ( x3 , y3 ) ) <EOL> result = contains ( polygon , Point ( xp , yp ) ) <EOL> if result == <NUM_LIT:2> : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( sys . argv [ <NUM_LIT:1> : ] )
"""<STR_LIT>""" <EOL> import sys <EOL> from sys import stdin <EOL> input = stdin . readline <EOL> class Point ( object ) : <EOL> epsilon = <NUM_LIT> <EOL> def __init__ ( self , x = <NUM_LIT:0.0> , y = <NUM_LIT:0.0> ) : <EOL> if isinstance ( x , tuple ) : <EOL> self . x = x [ <NUM_LIT:0> ] <EOL> self . y = x [ <NUM_LIT:1> ] <EOL> else : <EOL> self . x = x <EOL> self . y = y <EOL> def __add__ ( self , other ) : <EOL> return Point ( self . x + other . x , self . y + other . y ) <EOL> def __sub__ ( self , other ) : <EOL> return Point ( self . x - other . x , self . y - other . y ) <EOL> def __mul__ ( self , other ) : <EOL> return Point ( other * self . x , other * self . y ) <EOL> def __truediv__ ( self , other ) : <EOL> return Point ( self . x / other , self . y / other ) <EOL> def __lt__ ( self , other ) : <EOL> if self . x == other . x : <EOL> return self . y < other . y <EOL> else : <EOL> return self . x < other . x <EOL> def __eq__ ( self , other ) : <EOL> from math import fabs <EOL> if fabs ( self . x - other . x ) < Point . epsilon and fabs ( self . y - other . y ) < Point . epsilon : <EOL> return True <EOL> else : <EOL> return False <EOL> def norm ( self ) : <EOL> return self . x * self . x + self . y * self . y <EOL> def __abs__ ( self ) : <EOL> return sqrt ( self . norm ( ) ) <EOL> def ccw ( self , p0 , p1 ) : <EOL> a = Vector ( p1 - p0 ) <EOL> b = Vector ( self - p0 ) <EOL> if Vector . cross ( a , b ) > Point . epsilon : <EOL> return <NUM_LIT:1> <EOL> elif Vector . cross ( a , b ) < - Point . epsilon : <EOL> return - <NUM_LIT:1> <EOL> elif Vector . dot ( a , b ) < - Point . epsilon : <EOL> return <NUM_LIT:2> <EOL> elif a . norm ( ) < b . norm ( ) : <EOL> return - <NUM_LIT:2> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> def project ( self , s ) : <EOL> base = Vector ( s . p2 - s . p1 ) <EOL> a = Vector ( self - s . p1 ) <EOL> r = Vector . dot ( a , base ) <EOL> r /= base . norm ( ) <EOL> return s . p1 + base * r <EOL> def reflect ( self , s ) : <EOL> proj = self . project ( s ) <EOL> return self + ( proj - self ) * <NUM_LIT:2> <EOL> def distance ( self , s ) : <EOL> if Vector . dot ( s . p2 - s . p1 , self - s . p1 ) < <NUM_LIT:0.0> : <EOL> return abs ( self - s . p1 ) <EOL> if Vector . dot ( s . p1 - s . p2 , self - s . p2 ) < <NUM_LIT:0.0> : <EOL> return abs ( self - s . p2 ) <EOL> return abs ( Vector . cross ( s . p2 - s . p1 , self - s . p1 ) / abs ( s . p2 - s . p1 ) ) <EOL> class Vector ( Point ) : <EOL> def __init__ ( self , x = <NUM_LIT:0.0> , y = <NUM_LIT:0.0> ) : <EOL> if isinstance ( x , tuple ) : <EOL> self . x = x [ <NUM_LIT:0> ] <EOL> self . y = x [ <NUM_LIT:1> ] <EOL> elif isinstance ( x , Point ) : <EOL> self . x = x . x <EOL> self . y = x . y <EOL> else : <EOL> self . x = x <EOL> self . y = y <EOL> def __add__ ( self , other ) : <EOL> return Vector ( self . x + other . x , self . y + other . y ) <EOL> def __sub__ ( self , other ) : <EOL> return Vector ( self . x - other . x , self . y - other . y ) <EOL> def __mul__ ( self , other ) : <EOL> return Vector ( other * self . x , other * self . y ) <EOL> def __truediv__ ( self , other ) : <EOL> return Vector ( self . x / other , self . y / other ) <EOL> @ classmethod <EOL> def dot ( cls , a , b ) : <EOL> return a . x * b . x + a . y * b . y <EOL> @ classmethod <EOL> def cross ( cls , a , b ) : <EOL> return a . x * b . y - a . y * b . x <EOL> @ classmethod <EOL> def is_orthogonal ( cls , a , b ) : <EOL> return abs ( Vector . dot ( a , b ) ) < Vector . epsilon <EOL> @ classmethod <EOL> def is_parallel ( cls , a , b ) : <EOL> return abs ( Vector . cross ( a , b ) ) < Vector . epsilon <EOL> class Segment ( object ) : <EOL> def __init__ ( self , p1 = Point ( ) , p2 = Point ( ) ) : <EOL> if isinstance ( p1 , Point ) : <EOL> self . p1 = p1 <EOL> self . p2 = p2 <EOL> elif isinstance ( p1 , tuple ) : <EOL> self . p1 = Point ( p1 [ <NUM_LIT:0> ] , p1 [ <NUM_LIT:1> ] ) <EOL> self . p2 = Point ( p2 [ <NUM_LIT:0> ] , p2 [ <NUM_LIT:1> ] ) <EOL> def intersect ( self , s ) : <EOL> ans1 = s . p1 . ccw ( self . p1 , self . p2 ) * s . p2 . ccw ( self . p1 , self . p2 ) <EOL> ans2 = self . p1 . ccw ( s . p1 , s . p2 ) * self . p2 . ccw ( s . p1 , s . p2 ) <EOL> return ans1 <= <NUM_LIT:0> and ans2 <= <NUM_LIT:0> <EOL> def cross_point ( self , s ) : <EOL> base = s . p2 - s . p1 <EOL> d1 = abs ( Vector . cross ( base , self . p1 - s . p1 ) ) <EOL> d2 = abs ( Vector . cross ( base , self . p2 - s . p1 ) ) <EOL> t = d1 / ( d1 + d2 ) <EOL> return self . p1 + ( self . p2 - self . p1 ) * t <EOL> def distance ( self , s ) : <EOL> if self . intersect ( s ) : <EOL> return <NUM_LIT:0.0> <EOL> d1 = s . p1 . distance ( self ) <EOL> d2 = s . p2 . distance ( self ) <EOL> d3 = self . p1 . distance ( s ) <EOL> d4 = self . p2 . distance ( s ) <EOL> return min ( d1 , d2 , d3 , d4 ) <EOL> @ classmethod <EOL> def is_orthogonal ( cls , s1 , s2 ) : <EOL> a = Vector ( s1 . p2 - s1 . p1 ) <EOL> b = Vector ( s2 . p2 - s2 . p1 ) <EOL> return Vector . is_orthogonal ( a , b ) <EOL> @ classmethod <EOL> def is_parallel ( cls , s1 , s2 ) : <EOL> a = Vector ( s1 . p2 - s1 . p1 ) <EOL> b = Vector ( s2 . p2 - s2 . p1 ) <EOL> return Vector . is_parallel ( a , b ) <EOL> class Line ( Segment ) : <EOL> pass <EOL> class Cirle ( object ) : <EOL> def __init__ ( self , x , y = Point ( ) , r = <NUM_LIT:1.0> ) : <EOL> if isinstance ( x , Point ) : <EOL> self . c = x <EOL> self . r = y <EOL> elif isinstance ( x , tuple ) : <EOL> self . c = Point ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] ) <EOL> self . r = r <EOL> def cross_points ( self , s ) : <EOL> if isinstance ( s , Segment ) : <EOL> pr = self . c . project ( s ) <EOL> e = ( s . p2 - s . p1 ) / abs ( s . p2 - s . p1 ) <EOL> base = sqrt ( self . r * self . r - ( pr - self . c ) . norm ( ) ) <EOL> return pr + e * base , pr - e * base <EOL> elif isinstance ( s , Cirle ) : <EOL> c2 = s <EOL> d = abs ( self . c - c2 . c ) <EOL> a = acos ( ( self . r * self . r + d * d - c2 . r * c2 . r ) / ( <NUM_LIT:2> * self . r * d ) ) <EOL> t = atan2 ( c2 . c . y - self . c . y , c2 . c . x - self . c . x ) <EOL> temp1 = Point ( cos ( t + a ) * self . r , sin ( t + a ) * self . r ) <EOL> temp2 = Point ( cos ( t - a ) * self . r , sin ( t - a ) * self . r ) <EOL> return self . c + temp1 , self . c + temp2 <EOL> def contains ( polygon , p ) : <EOL> n = len ( polygon ) <EOL> x = False <EOL> for i in range ( n ) : <EOL> a = polygon [ i ] - p <EOL> b = polygon [ ( i + <NUM_LIT:1> ) % n ] - p <EOL> if abs ( Vector . cross ( a , b ) ) < Point . epsilon and Vector . dot ( a , b ) < Point . epsilon : <EOL> return <NUM_LIT:1> <EOL> if a . y > b . y : <EOL> temp = a <EOL> a = b <EOL> b = temp <EOL> if a . y < Point . epsilon and Point . epsilon < b . y and Vector . cross ( a , b ) > Point . epsilon : <EOL> x = not x <EOL> return <NUM_LIT:2> if x else <NUM_LIT:0> <EOL> def main ( args ) : <EOL> n = int ( input ( ) ) <EOL> for _ in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <EOL> a = Point ( x1 , y1 ) <EOL> b = Point ( x2 , y2 ) <EOL> c = Point ( x3 , y3 ) <EOL> d = Point ( x4 , y4 ) <EOL> AB = Segment ( a , b ) <EOL> CD = Segment ( c , d ) <EOL> result = Segment . is_parallel ( AB , CD ) <EOL> if result : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( sys . argv [ <NUM_LIT:1> : ] )
import sys <EOL> from decimal import Decimal <EOL> def is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <EOL> d1x = x2 - x1 <EOL> d1y = y2 - y1 <EOL> d2x = x4 - x3 <EOL> d2y = y4 - y3 <EOL> return d1x * d2y == d1y * d2x <EOL> def main ( ) : <EOL> n = int ( sys . stdin . readline ( ) . strip ( ) ) <EOL> for _ in range ( n ) : <EOL> data = sys . stdin . readline ( ) . strip ( ) . split ( '<STR_LIT:U+0020>' ) <EOL> x1 = Decimal ( data [ <NUM_LIT:0> ] ) <EOL> y1 = Decimal ( data [ <NUM_LIT:1> ] ) <EOL> x2 = Decimal ( data [ <NUM_LIT:2> ] ) <EOL> y2 = Decimal ( data [ <NUM_LIT:3> ] ) <EOL> x3 = Decimal ( data [ <NUM_LIT:4> ] ) <EOL> y3 = Decimal ( data [ <NUM_LIT:5> ] ) <EOL> x4 = Decimal ( data [ <NUM_LIT:6> ] ) <EOL> y4 = Decimal ( data [ <NUM_LIT:7> ] ) <EOL> if is_parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> class Paper ( object ) : <EOL> def __init__ ( self , x = None , y = None ) : <EOL> if x == None : <EOL> self . x = <NUM_LIT:10> <EOL> else : <EOL> self . x = x <EOL> if y == None : <EOL> self . y = <NUM_LIT:10> <EOL> else : <EOL> self . y = y <EOL> t = [ <NUM_LIT:0> ] * self . x <EOL> self . sheet = [ t [ : ] for _ in range ( self . y ) ] <EOL> def drop_ink ( self , ink ) : <EOL> x , y , s = ink <EOL> if s == <NUM_LIT:1> : <EOL> self . process_ink ( x , y ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y ) <EOL> self . process_ink ( x , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x , y - <NUM_LIT:1> ) <EOL> elif s == <NUM_LIT:2> : <EOL> self . process_ink ( x - <NUM_LIT:1> , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y ) <EOL> self . process_ink ( x , y ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y + <NUM_LIT:1> ) <EOL> elif s == <NUM_LIT:3> : <EOL> self . process_ink ( x , y - <NUM_LIT:2> ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y - <NUM_LIT:1> ) <EOL> self . process_ink ( x - <NUM_LIT:2> , y ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y ) <EOL> self . process_ink ( x , y ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y ) <EOL> self . process_ink ( x + <NUM_LIT:2> , y ) <EOL> self . process_ink ( x - <NUM_LIT:1> , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x + <NUM_LIT:1> , y + <NUM_LIT:1> ) <EOL> self . process_ink ( x , y + <NUM_LIT:2> ) <EOL> def process_ink ( self , x , y ) : <EOL> if <NUM_LIT:0> <= x < self . x and <NUM_LIT:0> <= y < self . y : <EOL> self . sheet [ y ] [ x ] += <NUM_LIT:1> <EOL> def print_sheet ( self ) : <EOL> for row in self . sheet : <EOL> print ( row ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> ink_drops = [ ] <EOL> for line in sys . stdin : <EOL> ink_drops . append ( [ int ( x ) for x in line . strip ( ) . split ( '<STR_LIT:U+002C>' ) ] ) <EOL> p = Paper ( <NUM_LIT:10> , <NUM_LIT:10> ) <EOL> for ink in ink_drops : <EOL> p . drop_ink ( ink ) <EOL> white_cell = <NUM_LIT:0> <EOL> max_ink = <NUM_LIT:0> <EOL> for r in p . sheet : <EOL> white_cell += r . count ( <NUM_LIT:0> ) <EOL> max_ink = max ( max ( r ) , max_ink ) <EOL> print ( white_cell ) <EOL> print ( max_ink )
def paint ( masu , data ) : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:2> ] == <NUM_LIT:1> : <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> elif data [ <NUM_LIT:2> ] == <NUM_LIT:2> : <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> and data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> and data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> and data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> and data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> elif data [ <NUM_LIT:2> ] == <NUM_LIT:3> : <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> and data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:9> and data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> and data [ <NUM_LIT:0> ] != <NUM_LIT:9> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] != <NUM_LIT:0> and data [ <NUM_LIT:0> ] != <NUM_LIT:0> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:1> ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] >= <NUM_LIT:2> : <EOL> masu [ data [ <NUM_LIT:1> ] - <NUM_LIT:2> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:1> ] <= <NUM_LIT:7> : <EOL> masu [ data [ <NUM_LIT:1> ] + <NUM_LIT:2> ] [ data [ <NUM_LIT:0> ] ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:0> ] >= <NUM_LIT:2> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if data [ <NUM_LIT:0> ] <= <NUM_LIT:7> : <EOL> masu [ data [ <NUM_LIT:1> ] ] [ data [ <NUM_LIT:0> ] + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> return masu <EOL> masu = [ <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] , <EOL> [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] <EOL> ] <EOL> def keisan ( masu ) : <EOL> max = <NUM_LIT:0> <EOL> num1 = <NUM_LIT:0> <EOL> for na in range ( <NUM_LIT:10> ) : <EOL> for ma in range ( <NUM_LIT:10> ) : <EOL> if masu [ na ] [ ma ] == <NUM_LIT:0> : <EOL> num1 += <NUM_LIT:1> <EOL> if masu [ na ] [ ma ] > max : <EOL> max = masu [ na ] [ ma ] <EOL> print ( num1 ) <EOL> print ( max ) <EOL> while True : <EOL> try : <EOL> x , y , s = list ( map ( int , input ( ) . split ( '<STR_LIT:U+002C>' ) ) ) <EOL> data = [ x , y , s ] <EOL> masu2 = paint ( masu , data ) <EOL> except : <EOL> break <EOL> keisan ( masu2 )
def perpendicular_bisector ( p , q ) : <EOL> x = ( q [ <NUM_LIT:0> ] - p [ <NUM_LIT:0> ] ) <EOL> y = ( q [ <NUM_LIT:1> ] - p [ <NUM_LIT:1> ] ) <EOL> return ( <NUM_LIT:2> * x , <NUM_LIT:2> * y , p [ <NUM_LIT:0> ] ** <NUM_LIT:2> - q [ <NUM_LIT:0> ] ** <NUM_LIT:2> + p [ <NUM_LIT:1> ] ** <NUM_LIT:2> - q [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) <EOL> def gauss_jordan_elimination ( Array ) : <EOL> N = len ( Array ) <EOL> if N == <NUM_LIT:0> : <EOL> return ( True , Array ) <EOL> else : <EOL> M = len ( Array [ <NUM_LIT:0> ] ) <EOL> A = [ ] <EOL> for i in range ( len ( Array ) ) : <EOL> A . append ( Array [ i ] [ : ] ) <EOL> pivot = <NUM_LIT:0> <EOL> L = min ( N , M ) <EOL> while pivot < L : <EOL> pivot_v = A [ pivot ] [ pivot ] <EOL> pivot_row = pivot <EOL> for i in range ( pivot + <NUM_LIT:1> , L ) : <EOL> v = max ( A [ i ] [ pivot ] , - A [ i ] [ pivot ] ) <EOL> if pivot_v < v : <EOL> pivot_row = i <EOL> pivot_v = v <EOL> if pivot_row > pivot : <EOL> for i in range ( M ) : <EOL> A [ pivot ] [ i ] , A [ pivot_row ] [ i ] = A [ pivot_row ] [ i ] , A [ pivot ] [ i ] <EOL> if pivot_v == <NUM_LIT:0> : <EOL> return ( '<STR_LIT:False>' , A ) <EOL> inv_pivot = <NUM_LIT:1> / A [ pivot ] [ pivot ] <EOL> A [ pivot ] [ pivot ] = <NUM_LIT:1> <EOL> for i in range ( pivot + <NUM_LIT:1> , M ) : <EOL> A [ pivot ] [ i ] *= inv_pivot <EOL> for i in range ( N ) : <EOL> if i == pivot : <EOL> continue <EOL> t = - <NUM_LIT:1> * A [ i ] [ pivot ] <EOL> A [ i ] [ pivot ] = <NUM_LIT:0> <EOL> for j in range ( pivot + <NUM_LIT:1> , M ) : <EOL> A [ i ] [ j ] += t * A [ pivot ] [ j ] <EOL> pivot += <NUM_LIT:1> <EOL> return ( '<STR_LIT:True>' , A ) <EOL> n = int ( input ( ) ) <EOL> for _ in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <EOL> a = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x2 , y2 ) ) ) <EOL> b = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x3 , y3 ) ) ) <EOL> c = [ a , b ] <EOL> state , c = gauss_jordan_elimination ( c ) <EOL> x = - c [ <NUM_LIT:0> ] [ <NUM_LIT:2> ] <EOL> y = - c [ <NUM_LIT:1> ] [ <NUM_LIT:2> ] <EOL> r = ( ( x - x1 ) ** <NUM_LIT:2> + ( y - y1 ) ** <NUM_LIT:2> ) ** <NUM_LIT:0.5> <EOL> print ( '<STR_LIT>' . format ( round ( x , <NUM_LIT:3> ) , round ( y , <NUM_LIT:3> ) , round ( r , <NUM_LIT:3> ) ) )
import math <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> n = int ( raw_input ( ) ) <EOL> for i in xrange ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . strip ( ) . split ( '<STR_LIT:U+0020>' ) ) <EOL> if math . fabs ( ( y2 - y1 ) * ( x4 - x3 ) - ( y4 - y3 ) * ( x2 - x1 ) ) < <NUM_LIT> : <EOL> print '<STR_LIT>' <EOL> else : <EOL> print '<STR_LIT>'
sheet = [ [ <NUM_LIT:0> for _ in range ( <NUM_LIT:10> ) ] for _ in range ( <NUM_LIT:10> ) ] <EOL> small_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) ) <EOL> middle_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) ) <EOL> large_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:2> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:2> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:2> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:2> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) ) <EOL> def drop ( x , y , drop_range ) : <EOL> for dx , dy in drop_range : <EOL> newx , newy = x + dx , y + dy <EOL> if <NUM_LIT:0> <= newx <= <NUM_LIT:9> and <NUM_LIT:0> <= newy <= <NUM_LIT:9> : <EOL> sheet [ newx ] [ newy ] += <NUM_LIT:1> <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if s == <NUM_LIT:1> : <EOL> drop ( x , y , small_range ) <EOL> elif s == <NUM_LIT:2> : <EOL> drop ( x , y , middle_range ) <EOL> else : <EOL> drop ( x , y , large_range ) <EOL> except EOFError : <EOL> break <EOL> zero_cnt = <NUM_LIT:0> <EOL> max_ink = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:10> ) : <EOL> for y in range ( <NUM_LIT:10> ) : <EOL> ink = sheet [ x ] [ y ] <EOL> if ink == <NUM_LIT:0> : <EOL> zero_cnt += <NUM_LIT:1> <EOL> if max_ink < ink : <EOL> max_ink = ink <EOL> print ( zero_cnt ) <EOL> print ( max_ink )
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy <EOL> sys . setrecursionlimit ( <NUM_LIT:10> ** <NUM_LIT:7> ) <EOL> inf = <NUM_LIT:10> ** <NUM_LIT:20> <EOL> mod = <NUM_LIT:10> ** <NUM_LIT:9> + <NUM_LIT:7> <EOL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <EOL> def I ( ) : return int ( sys . stdin . readline ( ) ) <EOL> def F ( ) : return float ( sys . stdin . readline ( ) ) <EOL> def S ( ) : return input ( ) <EOL> class Matrix ( ) : <EOL> def __init__ ( self , A ) : <EOL> self . A = A <EOL> self . row = len ( A ) <EOL> self . col = len ( A [ <NUM_LIT:0> ] ) <EOL> def __iter__ ( self ) : <EOL> return self . A . __iter__ ( ) <EOL> def __getitem__ ( self , i ) : <EOL> return self . A . __getitem__ ( i ) <EOL> def __add__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> return Matrix ( [ [ aa [ i ] [ j ] + bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <EOL> def __sub__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> return Matrix ( [ [ aa [ i ] [ j ] - bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <EOL> def __mul__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> a = [ ] <EOL> for i in range ( self . row ) : <EOL> ai = aa [ i ] <EOL> r = [ ] <EOL> for j in range ( B . col ) : <EOL> r . append ( sum ( [ ai [ k ] * bb [ k ] [ j ] for k in range ( self . col ) ] ) ) <EOL> a . append ( r ) <EOL> return Matrix ( a ) <EOL> def __truediv__ ( self , x ) : <EOL> pass <EOL> def lu ( self ) : <EOL> size = self . row <EOL> T = copy . deepcopy ( self . A ) <EOL> L = [ [ <NUM_LIT:0> ] * size for _ in range ( size ) ] <EOL> U = [ [ <NUM_LIT:0> ] * size for _ in range ( size ) ] <EOL> for i in range ( size ) : <EOL> for j in range ( i , size ) : <EOL> L [ j ] [ i ] = T [ j ] [ i ] <EOL> for j in range ( i , size ) : <EOL> U [ i ] [ j ] = T [ i ] [ j ] / T [ i ] [ i ] <EOL> for j in range ( i + <NUM_LIT:1> , size ) : <EOL> for k in range ( i + <NUM_LIT:1> , size ) : <EOL> T [ j ] [ k ] -= L [ j ] [ i ] * U [ i ] [ k ] <EOL> return Matrix ( L ) , Matrix ( U ) <EOL> def __str__ ( self ) : <EOL> return self . A . __str__ ( ) <EOL> def solve_se ( A , b ) : <EOL> n = A . row <EOL> L , U = A . lu ( ) <EOL> y = [ ] <EOL> for i in range ( n ) : <EOL> t = b [ i ] <EOL> for k in range ( i ) : <EOL> t -= L [ i ] [ k ] * y [ k ] <EOL> y . append ( t / L [ i ] [ i ] ) <EOL> x = [ <NUM_LIT:0> ] * n <EOL> for i in range ( n - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> t = y [ i ] <EOL> for k in range ( i + <NUM_LIT:1> , n ) : <EOL> t -= U [ i ] [ k ] * x [ k ] <EOL> x [ i ] = t <EOL> return x <EOL> def main ( ) : <EOL> sa = [ s for s in sys . stdin . read ( ) . split ( '<STR_LIT:\n>' ) if s ] <EOL> r = [ ] <EOL> for s in sa : <EOL> a , b , c , d , e , f = [ int ( c ) for c in s . split ( ) ] <EOL> A = Matrix ( [ [ a , b ] , [ d , e ] ] ) <EOL> B = [ c , f ] <EOL> x = solve_se ( A , B ) <EOL> r . append ( '<STR_LIT:U+0020>' . join ( map ( lambda t : '<STR_LIT>' . format ( <NUM_LIT:1.0> * t ) , x ) ) ) <EOL> return '<STR_LIT:\n>' . join ( r ) <EOL> print ( main ( ) )
class Point ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . x = x <EOL> self . y = y <EOL> def __str__ ( self ) : <EOL> return "<STR_LIT>" . format ( self . x , self . y ) <EOL> class Line ( Point ) : <EOL> eps = <NUM_LIT:10> ** ( - <NUM_LIT:10> ) <EOL> def __init__ ( self , p1 , p2 ) : <EOL> self . p1 = p1 <EOL> self . p2 = p2 <EOL> def isParallel ( self , another_p ) : <EOL> try : <EOL> angle1 = ( self . p1 . y - self . p2 . y ) / ( self . p1 . x - self . p2 . x ) <EOL> angle2 = ( another_p . p1 . y - another_p . p2 . y ) / ( another_p . p1 . x - another_p . p2 . x ) <EOL> if angle1 >= angle2 - self . eps and angle1 <= angle2 + self . eps : <EOL> return True <EOL> else : <EOL> return False <EOL> except ZeroDivisionError : <EOL> if self . p1 . x == self . p2 . x and another_p . p1 . x == another_p . p2 . x : <EOL> return True <EOL> else : <EOL> return False <EOL> n = int ( input ( ) ) <EOL> for i in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <EOL> A = Point ( x1 , y1 ) <EOL> B = Point ( x2 , y2 ) <EOL> C = Point ( x3 , y3 ) <EOL> D = Point ( x4 , y4 ) <EOL> AB = Line ( A , B ) <EOL> CD = Line ( C , D ) <EOL> if AB . isParallel ( CD ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" )
