class vector ( object ) : <EOL> def __init__ ( self , a , b ) : <EOL> self . x = b . x - a . x <EOL> self . y = b . y - a . y <EOL> @ staticmethod <EOL> def cross_product ( a , b ) : <EOL> return a . x * b . y - a . y * b . x <EOL> class vertex ( object ) : <EOL> def __init__ ( self , a ) : <EOL> self . x = a [ <NUM_LIT:0> ] <EOL> self . y = a [ <NUM_LIT:1> ] <EOL> class circle ( object ) : <EOL> def __init__ ( self , p , r ) : <EOL> self . px = p . x <EOL> self . py = p . y <EOL> self . r = r <EOL> class triangle ( object ) : <EOL> def __init__ ( self , a , b , c ) : <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> import math <EOL> self . ab = math . sqrt ( ( self . a . x - self . b . x ) ** <NUM_LIT:2> + ( self . a . y - self . b . y ) ** <NUM_LIT:2> ) <EOL> self . bc = math . sqrt ( ( self . b . x - self . c . x ) ** <NUM_LIT:2> + ( self . b . y - self . c . y ) ** <NUM_LIT:2> ) <EOL> self . ca = math . sqrt ( ( self . c . x - self . a . x ) ** <NUM_LIT:2> + ( self . c . y - self . a . y ) ** <NUM_LIT:2> ) <EOL> c = self . ab <EOL> a = self . bc <EOL> b = self . ca <EOL> self . cosA = ( b ** <NUM_LIT:2> + c ** <NUM_LIT:2> - a ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * c ) <EOL> self . cosB = ( a ** <NUM_LIT:2> + c ** <NUM_LIT:2> - b ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * a * c ) <EOL> self . cosC = ( b ** <NUM_LIT:2> + a ** <NUM_LIT:2> - c ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * a ) <EOL> self . sinA = math . sqrt ( <NUM_LIT:1> - self . cosA ** <NUM_LIT:2> ) <EOL> self . sinB = math . sqrt ( <NUM_LIT:1> - self . cosB ** <NUM_LIT:2> ) <EOL> self . sinC = math . sqrt ( <NUM_LIT:1> - self . cosC ** <NUM_LIT:2> ) <EOL> self . sin2A = <NUM_LIT:2> * self . sinA * self . cosA <EOL> self . sin2B = <NUM_LIT:2> * self . sinB * self . cosB <EOL> self . sin2C = <NUM_LIT:2> * self . sinC * self . cosC <EOL> def area ( self ) : <EOL> import math <EOL> s = ( self . ab + self . bc + self . ca ) / <NUM_LIT:2> <EOL> S = math . sqrt ( s * ( s - self . ab ) * ( s - self . bc ) * ( s - self . ca ) ) <EOL> return S <EOL> def circumscribed ( self ) : <EOL> R = self . ab / ( <NUM_LIT:2> * self . sinC ) <EOL> px = ( self . sin2A * self . a . x + self . sin2B * self . b . x + self . sin2C * self . c . x ) / ( self . sin2A + self . sin2B + self . sin2C ) <EOL> py = ( self . sin2A * self . a . y + self . sin2B * self . b . y + self . sin2C * self . c . y ) / ( self . sin2A + self . sin2B + self . sin2C ) <EOL> px = round ( px , <NUM_LIT:3> ) <EOL> py = round ( py , <NUM_LIT:3> ) <EOL> R = round ( R , <NUM_LIT:3> ) <EOL> p = vertex ( ( px , py ) ) <EOL> return circle ( p , R ) <EOL> def isin ( self , p ) : <EOL> AB = vector ( self . a , self . b ) <EOL> BC = vector ( self . b , self . c ) <EOL> CA = vector ( self . c , self . a ) <EOL> AP = vector ( self . a , p ) <EOL> BP = vector ( self . b , p ) <EOL> CP = vector ( self . c , p ) <EOL> if ( vector . cross_product ( AB , AP ) > <NUM_LIT:0> and vector . cross_product ( BC , BP ) > <NUM_LIT:0> and vector . cross_product ( CA , CP ) > <NUM_LIT:0> ) or ( vector . cross_product ( AB , AP ) < <NUM_LIT:0> and vector . cross_product ( BC , BP ) < <NUM_LIT:0> and vector . cross_product ( CA , CP ) < <NUM_LIT:0> ) : <EOL> return '<STR_LIT>' <EOL> else : return '<STR_LIT>' <EOL> A = [ ] <EOL> B = [ ] <EOL> C = [ ] <EOL> p = [ ] <EOL> import sys <EOL> for line in sys . stdin : <EOL> a , b , c , d , e , f , g , h = list ( map ( float , line . split ( ) ) ) <EOL> A . append ( vertex ( ( a , b ) ) ) <EOL> B . append ( vertex ( ( c , d ) ) ) <EOL> C . append ( vertex ( ( e , f ) ) ) <EOL> p . append ( vertex ( ( g , h ) ) ) <EOL> for i in range ( len ( A ) ) : <EOL> Triangle = triangle ( A [ i ] , B [ i ] , C [ i ] ) <EOL> print ( Triangle . isin ( p [ i ] ) )
import sys <EOL> def Print ( array ) : <EOL> for r in range ( len ( array ) ) : <EOL> print ( array [ r ] ) <EOL> print ( ) <EOL> def Gauss ( array ) : <EOL> for r in range ( len ( array ) ) : <EOL> div = array [ r ] [ r ] <EOL> for c in range ( r , len ( array ) + <NUM_LIT:1> ) : <EOL> array [ r ] [ c ] /= div <EOL> for r2 in range ( r + <NUM_LIT:1> , len ( array ) ) : <EOL> head = array [ r2 ] [ r ] <EOL> for c in range ( r , len ( array ) + <NUM_LIT:1> ) : <EOL> array [ r2 ] [ c ] -= head * array [ r ] [ c ] <EOL> result = [ <NUM_LIT:0> ] * len ( array ) <EOL> for r in range ( len ( array ) - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> result [ r ] = array [ r ] [ <EOL> len ( array ) ] - sum ( [ result [ x ] * array [ r ] [ x ] for x in range ( r + <NUM_LIT:1> , len ( array ) ) ] ) <EOL> return result <EOL> for line in sys . stdin : <EOL> [ a , b , c , d , e , f ] = [ int ( x ) for x in line . split ( ) ] <EOL> result = Gauss ( [ [ a , b , c ] , [ d , e , f ] ] ) <EOL> for i in range ( len ( result ) - <NUM_LIT:1> ) : <EOL> print ( "<STR_LIT>" . format ( result [ i ] ) , end = "<STR_LIT:U+0020>" ) <EOL> print ( "<STR_LIT>" . format ( result [ - <NUM_LIT:1> ] ) )
import sys <EOL> def length ( a , b ) : <EOL> return ( ( a [ <NUM_LIT:0> ] - b [ <NUM_LIT:0> ] ) ** <NUM_LIT:2> + ( a [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] ) ** <NUM_LIT:2> ) ** <NUM_LIT:0.5> <EOL> def solve_sim_equ ( a , b , c , d , e , f ) : <EOL> '''<STR_LIT>''' <EOL> if a == <NUM_LIT:0> and d == <NUM_LIT:0> : <EOL> if b == <NUM_LIT:0> and e == <NUM_LIT:0> : <EOL> return <NUM_LIT:0.> , <NUM_LIT:0.> <EOL> if b != <NUM_LIT:0> : <EOL> return <NUM_LIT:0.> , c / b + <NUM_LIT:0.> <EOL> else : <EOL> return <NUM_LIT:0.> , f / e + <NUM_LIT:0.> <EOL> elif b == <NUM_LIT:0> and e == <NUM_LIT:0> : <EOL> if a != <NUM_LIT:0> : <EOL> return <NUM_LIT:0.> , d / a + <NUM_LIT:0.> <EOL> else : <EOL> return <NUM_LIT:0.> , a / d + <NUM_LIT:0.> <EOL> if b == <NUM_LIT:0> : <EOL> a , d = d , a <EOL> b , e = e , b <EOL> c , f = f , c <EOL> g = e / b <EOL> x = ( g * c - f ) / ( g * a - d ) <EOL> y = ( c - a * x ) / b <EOL> return x + <NUM_LIT:0.> , y + <NUM_LIT:0.> <EOL> def circumscribed_circle ( x , y , z ) : <EOL> def get_equ_coef ( p , q ) : <EOL> h_x = ( p [ <NUM_LIT:0> ] + q [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> h_y = ( p [ <NUM_LIT:1> ] + q [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> a = q [ <NUM_LIT:1> ] - p [ <NUM_LIT:1> ] <EOL> b = p [ <NUM_LIT:0> ] - q [ <NUM_LIT:0> ] <EOL> c = b * h_x - a * h_y <EOL> return b , - a , c <EOL> coef = get_equ_coef ( x , y ) + get_equ_coef ( y , z ) <EOL> center = solve_sim_equ ( * coef ) <EOL> r = length ( center , x ) <EOL> return center , r <EOL> def main ( ) : <EOL> N = int ( input ( ) ) <EOL> for i in range ( N ) : <EOL> vs = [ float ( v ) for v in input ( ) . split ( ) ] <EOL> a = ( vs [ <NUM_LIT:0> ] , vs [ <NUM_LIT:1> ] ) <EOL> b = ( vs [ <NUM_LIT:2> ] , vs [ <NUM_LIT:3> ] ) <EOL> c = ( vs [ <NUM_LIT:4> ] , vs [ <NUM_LIT:5> ] ) <EOL> center , r = circumscribed_circle ( a , b , c ) <EOL> print ( '<STR_LIT>' . format ( center [ <NUM_LIT:0> ] , center [ <NUM_LIT:1> ] , r ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> def solve ( ) : <EOL> while True : <EOL> n = input ( ) <EOL> if n > <NUM_LIT:0> : <EOL> tmp_lst = [ ] <EOL> for i in xrange ( n ) : <EOL> tmp_lst . append ( input ( ) ) <EOL> lst = compress ( tmp_lst ) <EOL> accumurate_lst = calc_accumurate_lst ( lst ) <EOL> max_value = - ( <NUM_LIT:10> ** <NUM_LIT:100> ) <EOL> size = len ( lst ) <EOL> for to in xrange ( size ) : <EOL> for frm in xrange ( to + <NUM_LIT:1> ) : <EOL> value = accumurate_lst [ to ] if frm == <NUM_LIT:0> else accumurate_lst [ to ] - accumurate_lst [ frm - <NUM_LIT:1> ] <EOL> if max_value < value : <EOL> max_value = value <EOL> print max_value <EOL> else : <EOL> sys . exit ( ) <EOL> def calc_accumurate_lst ( lst ) : <EOL> accum = [ <NUM_LIT:0> for i in lst ] <EOL> accum [ <NUM_LIT:0> ] = lst [ <NUM_LIT:0> ] <EOL> for i in xrange ( <NUM_LIT:1> , len ( lst ) ) : <EOL> accum [ i ] = accum [ i - <NUM_LIT:1> ] + lst [ i ] <EOL> return accum <EOL> def compress ( tmp_lst ) : <EOL> lim = len ( tmp_lst ) <EOL> lst = [ ] <EOL> index = <NUM_LIT:0> <EOL> while index < lim : <EOL> tmp = tmp_lst [ index ] <EOL> index += <NUM_LIT:1> <EOL> while tmp > <NUM_LIT:0> and index < lim and tmp * tmp_lst [ index ] > <NUM_LIT:0> : <EOL> tmp += tmp_lst [ index ] <EOL> index += <NUM_LIT:1> <EOL> lst . append ( tmp ) <EOL> return lst <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> solve ( )
answermap = [ <NUM_LIT:0> ] * <NUM_LIT> <EOL> answermap [ <NUM_LIT:0> ] = <NUM_LIT:1> <EOL> answermap [ <NUM_LIT:1> ] = <NUM_LIT:4> <EOL> answermap [ <NUM_LIT:2> ] = <NUM_LIT:10> <EOL> answermap [ <NUM_LIT:3> ] = <NUM_LIT:20> <EOL> answermap [ <NUM_LIT:4> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:5> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:6> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:7> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:8> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:9> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:10> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:11> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:12> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:15> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:16> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:20> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:30> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT:32> ] = <NUM_LIT> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:20> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:10> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:4> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:1> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT> ] = <NUM_LIT:0> <EOL> answermap [ <NUM_LIT:50> ] = <NUM_LIT:0> <EOL> inputs = [ ] <EOL> while True : <EOL> try : <EOL> inputs . append ( int ( input ( ) ) ) <EOL> except EOFError : <EOL> break <EOL> for i in inputs : <EOL> print ( answermap [ i ] )
p = [ [ <NUM_LIT:0> for a in range ( <NUM_LIT:10> ) ] for b in range ( <NUM_LIT:10> ) ] <EOL> def smallink ( x , y ) : <EOL> return [ ( x + i , y + j ) for i in range ( - <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:1> ) for j in range ( - <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:1> ) if abs ( i ) + abs ( j ) <= <NUM_LIT:1> and x + i >= <NUM_LIT:0> and x + i <= <NUM_LIT:9> and y + j >= <NUM_LIT:0> and y + j <= <NUM_LIT:9> ] <EOL> def ink ( x , y ) : <EOL> return [ ( x + i , y + j ) for i in range ( - <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:1> ) for j in range ( - <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT:1> ) if x + i >= <NUM_LIT:0> and y + j >= <NUM_LIT:0> and x + i <= <NUM_LIT:9> and y + j <= <NUM_LIT:9> ] <EOL> def bigink ( x , y ) : <EOL> return [ ( x + i , y + j ) for i in range ( - <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> ) for j in range ( - <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:1> ) if abs ( i ) + abs ( j ) <= <NUM_LIT:2> and x + i >= <NUM_LIT:0> and y + j >= <NUM_LIT:0> and x + i <= <NUM_LIT:9> and y + j <= <NUM_LIT:9> ] <EOL> while True : <EOL> try : <EOL> x , y , size = map ( int , raw_input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if size == <NUM_LIT:1> : <EOL> L = smallink ( x , y ) <EOL> elif size == <NUM_LIT:2> : <EOL> L = ink ( x , y ) <EOL> else : <EOL> L = bigink ( x , y ) <EOL> while len ( L ) != <NUM_LIT:0> : <EOL> point = L . pop ( <NUM_LIT:0> ) <EOL> p [ point [ <NUM_LIT:0> ] ] [ point [ <NUM_LIT:1> ] ] += <NUM_LIT:1> <EOL> except : <EOL> break <EOL> count = <NUM_LIT:0> <EOL> max = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if ( p [ i ] [ j ] > max ) : <EOL> max = p [ i ] [ j ] <EOL> if ( p [ i ] [ j ] == <NUM_LIT:0> ) : <EOL> count += <NUM_LIT:1> <EOL> print count <EOL> print max
mass = [ [ <NUM_LIT:0> for p in xrange ( <NUM_LIT> ) ] for q in xrange ( <NUM_LIT> ) ] <EOL> while True : <EOL> try : <EOL> x , y , size = map ( int , raw_input ( ) . split ( '<STR_LIT:U+002C>' ) ) <EOL> x += <NUM_LIT:2> ; y += <NUM_LIT:2> <EOL> if size == <NUM_LIT:1> : <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> elif size == <NUM_LIT:2> : <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> elif size == <NUM_LIT:3> : <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> ; mass [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:0> <EOL> mass [ x - <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> ; mass [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> ; mass [ x + <NUM_LIT:2> ] [ y + <NUM_LIT:2> ] += <NUM_LIT:0> <EOL> except : break <EOL> white = <NUM_LIT:0> <EOL> max = <NUM_LIT:0> <EOL> for p in xrange ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> for q in xrange ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> if mass [ p ] [ q ] == <NUM_LIT:0> : white += <NUM_LIT:1> <EOL> if mass [ p ] [ q ] > max : max = mass [ p ] [ q ] <EOL> print white <EOL> print max
import cmath <EOL> class Point ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . point = complex ( x , y ) <EOL> def __str__ ( self ) : <EOL> return "<STR_LIT>" . format ( self . point . real , self . point . imag ) <EOL> class Triangle ( Point ) : <EOL> def __init__ ( self , a , b , c ) : <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> self . edgeA = abs ( b . point - c . point ) <EOL> self . edgeB = abs ( c . point - a . point ) <EOL> self . edgeC = abs ( a . point - b . point ) <EOL> self . angleA = Triangle . angle ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleB = Triangle . angle ( self . edgeB , self . edgeC , self . edgeA ) <EOL> self . angleC = Triangle . angle ( self . edgeC , self . edgeA , self . edgeB ) <EOL> def angle ( A , B , C ) : <EOL> return cmath . acos ( ( B * B + C * C - A * A ) / ( <NUM_LIT:2> * B * C ) ) <EOL> def circumscribedCircleRadius ( self ) : <EOL> return abs ( ( self . edgeA / cmath . sin ( self . angleA ) ) / <NUM_LIT:2> ) <EOL> def circumscribedCircleCenter ( self ) : <EOL> A = cmath . sin ( <NUM_LIT:2> * self . angleA ) <EOL> B = cmath . sin ( <NUM_LIT:2> * self . angleB ) <EOL> C = cmath . sin ( <NUM_LIT:2> * self . angleC ) <EOL> X = ( self . a . point . real * A + self . b . point . real * B + self . c . point . real * C ) / ( A + B + C ) <EOL> Y = ( self . a . point . imag * A + self . b . point . imag * B + self . c . point . imag * C ) / ( A + B + C ) <EOL> return complex ( X , Y ) <EOL> n = int ( input ( ) ) <EOL> for i in range ( n ) : <EOL> line = list ( map ( float , input ( ) . split ( ) ) ) <EOL> p1 = Point ( line [ <NUM_LIT:0> ] , line [ <NUM_LIT:1> ] ) <EOL> p2 = Point ( line [ <NUM_LIT:2> ] , line [ <NUM_LIT:3> ] ) <EOL> p3 = Point ( line [ <NUM_LIT:4> ] , line [ <NUM_LIT:5> ] ) <EOL> T = Triangle ( p1 , p2 , p3 ) <EOL> center = T . circumscribedCircleCenter ( ) <EOL> print ( "<STR_LIT>" . format ( center . real , center . imag , T . circumscribedCircleRadius ( ) ) )
from __future__ import ( division , absolute_import , print_function , <EOL> unicode_literals ) <EOL> from sys import stdin <EOL> from operator import attrgetter <EOL> from collections import namedtuple <EOL> Point = namedtuple ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> def linear ( p1 , p2 ) : <EOL> gradient = ( p1 . y - p2 . y ) / ( p1 . x - p2 . x ) <EOL> y_intercept = p1 . y - gradient * p1 . x <EOL> return lambda x : gradient * x + y_intercept <EOL> def takeout ( seq ) : <EOL> gen = ( Point ( next ( seq ) , next ( seq ) ) for _ in xrange ( <NUM_LIT:3> ) ) <EOL> for p in sorted ( gen , key = attrgetter ( '<STR_LIT:x>' ) ) : <EOL> yield p <EOL> yield Point ( next ( seq ) , next ( seq ) ) <EOL> for line in stdin : <EOL> A , B , C , P = takeout ( float ( s ) for s in line . split ( ) ) <EOL> assert A . x <= B . x <= C . x <EOL> if P . x <= A . x or C . x <= P . x : <EOL> print ( '<STR_LIT>' ) <EOL> continue <EOL> if A . x == B . x or B . x <= P . x <= C . x : <EOL> L = ( linear ( B , C ) , linear ( A , C ) ) <EOL> elif B . x == C . x or A . x <= P . x <= B . x : <EOL> L = ( linear ( A , B ) , linear ( A , C ) ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> continue <EOL> y1 , y2 = sorted ( f ( P . x ) for f in L ) <EOL> if y1 < P . y < y2 : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' )
def func ( a , b , c , d ) : <EOL> k = ( d - b ) / ( c - a ) <EOL> h = d - k * c <EOL> return k , h <EOL> def fx ( a , b , c , d , x ) : <EOL> k , h = func ( a , b , c , d ) <EOL> return k * x + h <EOL> def main ( ) : <EOL> import sys <EOL> for dataset in sys . stdin : <EOL> ans = '<STR_LIT>' <EOL> try : <EOL> a , b , c , d , e , f , px , py = map ( float , dataset . split ( ) ) <EOL> except : <EOL> break <EOL> T = [ ( a , b ) , ( c , d ) , ( e , f ) ] <EOL> T . sort ( key = lambda x : ( x [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] ) ) <EOL> a , b , c , d , e , f = T [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , T [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] , T [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , T [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] , T [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , T [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] <EOL> if a == c : <EOL> if a < px and fx ( a , b , e , f , px ) < py and fx ( c , d , e , f , px ) > py : <EOL> ans = '<STR_LIT>' <EOL> elif c == e : <EOL> if px < e and fx ( a , b , c , d , px ) < py and fx ( a , b , e , f , px ) > py : <EOL> ans = '<STR_LIT>' <EOL> else : <EOL> if fx ( a , b , e , f , c ) < d : <EOL> if fx ( a , b , c , d , px ) > py and fx ( c , d , e , f , px ) > py and fx ( a , b , e , f , px ) < py : <EOL> ans = '<STR_LIT>' <EOL> else : <EOL> if fx ( a , b , c , d , px ) < py and fx ( c , d , e , f , px ) < py and fx ( a , b , e , f , px ) > py : <EOL> ans = '<STR_LIT>' <EOL> print ( ans ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import math <EOL> PI = math . pi <EOL> EPS = <NUM_LIT:10> ** - <NUM_LIT:10> <EOL> def edge ( a , b ) : <EOL> return ( ( a [ <NUM_LIT:0> ] - b [ <NUM_LIT:0> ] ) ** <NUM_LIT:2> + ( a [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] ) ** <NUM_LIT:2> ) ** <NUM_LIT> <EOL> def area ( a , b , c ) : <EOL> s = ( a + b + c ) / <NUM_LIT:2> <EOL> return ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** <NUM_LIT> <EOL> def LawOfCosines ( a , b , c ) : <EOL> return math . acos ( ( b * b + c * c - a * a ) / ( <NUM_LIT> * b * c ) ) ; <EOL> def is_same ( x , y ) : <EOL> return abs ( x - y ) < EPS <EOL> class Triangle : <EOL> def __init__ ( self , p ) : <EOL> a , b , c = p <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> self . edgeA = edge ( b , c ) <EOL> self . edgeB = edge ( c , a ) <EOL> self . edgeC = edge ( a , b ) <EOL> self . area = area ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleA = LawOfCosines ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleB = LawOfCosines ( self . edgeB , self . edgeC , self . edgeA ) <EOL> self . angleC = LawOfCosines ( self . edgeC , self . edgeA , self . edgeB ) <EOL> def circumscribeadCircleRadius ( self ) : <EOL> return self . edgeA / math . sin ( self . angleA ) / <NUM_LIT> <EOL> def circumscribedCircleCenter ( self ) : <EOL> a = math . sin ( <NUM_LIT> * self . angleA ) ; <EOL> b = math . sin ( <NUM_LIT> * self . angleB ) ; <EOL> c = math . sin ( <NUM_LIT> * self . angleC ) ; <EOL> X = ( self . a [ <NUM_LIT:0> ] * a + self . b [ <NUM_LIT:0> ] * b + self . c [ <NUM_LIT:0> ] * c ) / ( a + b + c ) ; <EOL> Y = ( self . a [ <NUM_LIT:1> ] * a + self . b [ <NUM_LIT:1> ] * b + self . c [ <NUM_LIT:1> ] * c ) / ( a + b + c ) ; <EOL> return X , Y <EOL> def inscribedCircleRadius ( self ) : <EOL> return <NUM_LIT:2> * self . area / ( self . edgeA + self . edgeB + self . edgeC ) <EOL> def inscribedCircleCenter ( self ) : <EOL> points = [ self . a , self . b , self . c ] <EOL> edges = [ self . edgeA , self . edgeB , self . edgeC ] <EOL> s = sum ( edges ) <EOL> return [ sum ( [ points [ j ] [ i ] * edges [ j ] for j in range ( <NUM_LIT:3> ) ] ) / s for i in range ( <NUM_LIT:2> ) ] <EOL> def isInner ( self , p ) : <EOL> cross = lambda a , b : a [ <NUM_LIT:0> ] * b [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] * b [ <NUM_LIT:0> ] <EOL> c1 = <NUM_LIT:0> <EOL> c2 = <NUM_LIT:0> <EOL> points = [ self . a , self . b , self . c ] <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> a = [ points [ i ] [ <NUM_LIT:0> ] - points [ ( i + <NUM_LIT:1> ) % <NUM_LIT:3> ] [ <NUM_LIT:0> ] , points [ i ] [ <NUM_LIT:1> ] - points [ ( i + <NUM_LIT:1> ) % <NUM_LIT:3> ] [ <NUM_LIT:1> ] ] <EOL> b = [ points [ i ] [ <NUM_LIT:0> ] - p [ <NUM_LIT:0> ] , points [ i ] [ <NUM_LIT:1> ] - p [ <NUM_LIT:1> ] ] <EOL> c = cross ( a , b ) <EOL> if c > <NUM_LIT:0> : <EOL> c1 += <NUM_LIT:1> <EOL> elif c < <NUM_LIT:0> : <EOL> c2 += <NUM_LIT:1> <EOL> if c1 == <NUM_LIT:3> or c2 == <NUM_LIT:3> : <EOL> return True <EOL> else : <EOL> return c1 + c2 != <NUM_LIT:3> and ( c1 == <NUM_LIT:0> or c2 == <NUM_LIT:0> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> n = int ( input ( ) ) <EOL> for _ in range ( n ) : <EOL> points = [ ] <EOL> c = list ( map ( float , input ( ) . split ( ) ) ) <EOL> points = [ ( c [ i ] , c [ i + <NUM_LIT:1> ] ) for i in range ( <NUM_LIT:0> , <NUM_LIT:6> , <NUM_LIT:2> ) ] <EOL> t = Triangle ( points ) <EOL> x , y = t . circumscribedCircleCenter ( ) <EOL> r = t . circumscribeadCircleRadius ( ) <EOL> print ( "<STR_LIT>" . format ( x , y , r ) )
def check ( x , i , y , j ) : <EOL> flagx = True if ( x + i >= <NUM_LIT:0> and x + i <= <NUM_LIT:9> ) else False <EOL> flagy = True if ( y + j >= <NUM_LIT:0> and y + j <= <NUM_LIT:9> ) else False <EOL> return ( flagx and flagy ) <EOL> def main ( ) : <EOL> LIST = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> LIST . append ( [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) <EOL> count = <NUM_LIT:0> <EOL> M = <NUM_LIT:0> <EOL> while True : <EOL> try : <EOL> x , y , size = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if size == <NUM_LIT:1> : <EOL> for i in range ( - <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> for j in range ( - <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if check ( x , i , y , j ) and abs ( i ) + abs ( j ) <= <NUM_LIT:1> : <EOL> LIST [ y + j ] [ x + i ] += <NUM_LIT:1> <EOL> elif size == <NUM_LIT:2> : <EOL> for i in range ( - <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> for j in range ( - <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if check ( x , i , y , j ) and abs ( i ) + abs ( j ) <= <NUM_LIT:2> : <EOL> LIST [ y + j ] [ x + i ] += <NUM_LIT:1> <EOL> elif size == <NUM_LIT:3> : <EOL> for i in range ( - <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> for j in range ( - <NUM_LIT:2> , <NUM_LIT:3> ) : <EOL> if check ( x , i , y , j ) and abs ( i ) + abs ( j ) <= <NUM_LIT:2> : <EOL> LIST [ y + j ] [ x + i ] += <NUM_LIT:1> <EOL> except : <EOL> break <EOL> for item in LIST : <EOL> tmp = max ( x for x in item ) <EOL> M = max ( tmp , M ) <EOL> for item in LIST : <EOL> count += item . count ( <NUM_LIT:0> ) <EOL> print ( count ) <EOL> print ( M ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
from math import sqrt <EOL> n = int ( input ( ) ) <EOL> for i in range ( n ) : <EOL> tmp = input ( ) . split ( '<STR_LIT:U+0020>' ) <EOL> a , b , c = [ ( float ( tmp [ i ] ) , float ( tmp [ i + <NUM_LIT:1> ] ) ) for i in range ( <NUM_LIT:0> , len ( tmp ) , <NUM_LIT:2> ) ] <EOL> A_tmp1 = <NUM_LIT:1> / ( a [ <NUM_LIT:0> ] * b [ <NUM_LIT:1> ] + a [ <NUM_LIT:1> ] * c [ <NUM_LIT:0> ] + b [ <NUM_LIT:0> ] * c [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] * c [ <NUM_LIT:0> ] - a [ <NUM_LIT:1> ] * b [ <NUM_LIT:0> ] - a [ <NUM_LIT:0> ] * c [ <NUM_LIT:1> ] ) <EOL> A_tmp2 = [ [ b [ <NUM_LIT:1> ] - c [ <NUM_LIT:1> ] , - ( a [ <NUM_LIT:1> ] - c [ <NUM_LIT:1> ] ) , a [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] ] , <EOL> [ - ( b [ <NUM_LIT:0> ] - c [ <NUM_LIT:0> ] ) , ( a [ <NUM_LIT:0> ] - c [ <NUM_LIT:0> ] ) , - ( a [ <NUM_LIT:0> ] - b [ <NUM_LIT:0> ] ) ] , <EOL> [ b [ <NUM_LIT:0> ] * c [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] * c [ <NUM_LIT:0> ] , - ( a [ <NUM_LIT:0> ] * c [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] * c [ <NUM_LIT:0> ] ) , a [ <NUM_LIT:0> ] * b [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] * b [ <NUM_LIT:0> ] ] ] <EOL> A = [ list ( map ( lambda x : A_tmp1 * x , A_tmp2 [ i ] ) ) for i in range ( <NUM_LIT:3> ) ] <EOL> B = [ [ - ( a [ <NUM_LIT:0> ] ** <NUM_LIT:2> + a [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) ] , <EOL> [ - ( b [ <NUM_LIT:0> ] ** <NUM_LIT:2> + b [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) ] , <EOL> [ - ( c [ <NUM_LIT:0> ] ** <NUM_LIT:2> + c [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) ] ] <EOL> tmp = [ sum ( [ A [ i ] [ j ] * B [ j ] [ <NUM_LIT:0> ] for j in range ( <NUM_LIT:3> ) ] ) for i in range ( <NUM_LIT:3> ) ] <EOL> x = - tmp [ <NUM_LIT:0> ] / <NUM_LIT:2> <EOL> y = - tmp [ <NUM_LIT:1> ] / <NUM_LIT:2> <EOL> r = sqrt ( ( tmp [ <NUM_LIT:0> ] ** <NUM_LIT:2> + tmp [ <NUM_LIT:1> ] ** <NUM_LIT:2> - <NUM_LIT:4> * tmp [ <NUM_LIT:2> ] ) / <NUM_LIT:4> ) <EOL> print ( '<STR_LIT>' . format ( x , y , r ) )
Masu = [ ] <EOL> def access ( x , y ) : <EOL> if x < <NUM_LIT:0> or y < <NUM_LIT:0> or x > <NUM_LIT:9> or y > <NUM_LIT:9> : <EOL> return <EOL> Masu [ y ] [ x ] += <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> Masu . append ( [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> ] ) <EOL> kosu = <NUM_LIT:0> <EOL> komax = <NUM_LIT:0> <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if s == <NUM_LIT:1> : <EOL> for j in range ( <NUM_LIT:3> ) : <EOL> access ( y + <NUM_LIT:1> - j , x ) <EOL> access ( y , x - <NUM_LIT:1> ) <EOL> access ( y , x + <NUM_LIT:1> ) <EOL> elif s == <NUM_LIT:2> : <EOL> for k in range ( <NUM_LIT:3> ) : <EOL> for l in range ( <NUM_LIT:3> ) : <EOL> access ( y + <NUM_LIT:1> - k , x + <NUM_LIT:1> - l ) <EOL> elif s == <NUM_LIT:3> : <EOL> for k in range ( <NUM_LIT:3> ) : <EOL> for l in range ( <NUM_LIT:3> ) : <EOL> access ( y + <NUM_LIT:1> - k , x + <NUM_LIT:1> - l ) <EOL> access ( y - <NUM_LIT:2> , x ) <EOL> access ( y + <NUM_LIT:2> , x ) <EOL> access ( y , x + <NUM_LIT:2> ) <EOL> access ( y , x - <NUM_LIT:2> ) <EOL> except ( EOFError , ValueError ) : <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> kosu += Masu [ i ] . count ( <NUM_LIT:0> ) <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if komax < max ( Masu [ j ] ) : <EOL> komax = max ( Masu [ j ] ) <EOL> print ( kosu ) <EOL> print ( komax ) <EOL> break
arr = [ <NUM_LIT:0> ] * <NUM_LIT:100> <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if s == <NUM_LIT:3> : <EOL> if x <= <NUM_LIT:7> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:2> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if y <= <NUM_LIT:7> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:20> ] += <NUM_LIT:1> <EOL> if y >= <NUM_LIT:2> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:20> ] += <NUM_LIT:1> <EOL> if s >= <NUM_LIT:2> : <EOL> if x != <NUM_LIT:9> and y != <NUM_LIT:9> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:11> ] += <NUM_LIT:1> <EOL> if x != <NUM_LIT:9> and y != <NUM_LIT:0> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:9> ] += <NUM_LIT:1> <EOL> if x != <NUM_LIT:0> and y != <NUM_LIT:0> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:11> ] += <NUM_LIT:1> <EOL> if x != <NUM_LIT:0> and y != <NUM_LIT:9> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:9> ] += <NUM_LIT:1> <EOL> if True : <EOL> if x != <NUM_LIT:9> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x != <NUM_LIT:0> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y != <NUM_LIT:9> : <EOL> arr [ <NUM_LIT:10> * y + x + <NUM_LIT:10> ] += <NUM_LIT:1> <EOL> if y != <NUM_LIT:0> : <EOL> arr [ <NUM_LIT:10> * y + x - <NUM_LIT:10> ] += <NUM_LIT:1> <EOL> if True : <EOL> if True : <EOL> arr [ <NUM_LIT:10> * y + x ] += <NUM_LIT:1> <EOL> except EOFError : <EOL> break <EOL> print ( arr . count ( <NUM_LIT:0> ) ) <EOL> print ( max ( arr ) )
import sys <EOL> import math <EOL> prim_no = { <NUM_LIT:2> : True } <EOL> def is_prime ( no ) : <EOL> if no == <NUM_LIT:2> or no == <NUM_LIT:1> : <EOL> return True <EOL> if no % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> return False <EOL> if prim_no . get ( no ) is not None : <EOL> return prim_no . get ( no ) <EOL> max_check = int ( math . sqrt ( no ) ) <EOL> for i in range ( <NUM_LIT:3> , max_check + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if no % i == <NUM_LIT:0> : <EOL> prim_no [ no ] = False <EOL> return False <EOL> prim_no [ no ] = True <EOL> return True <EOL> def main ( ) : <EOL> prim_vals = { } <EOL> while True : <EOL> num = sys . stdin . readline ( ) <EOL> if num is None or num . strip ( ) == '<STR_LIT>' : <EOL> break <EOL> num = int ( num . strip ( ) ) <EOL> if prim_vals . get ( num ) is not None : <EOL> cnt = prim_vals . get ( num ) <EOL> else : <EOL> if num == <NUM_LIT:1> : <EOL> cnt = <NUM_LIT:0> <EOL> else : <EOL> cnt = <NUM_LIT:0> <EOL> if num % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> start_num = num - <NUM_LIT:1> <EOL> else : <EOL> start_num = num <EOL> for i in range ( start_num , <NUM_LIT:0> , - <NUM_LIT:2> ) : <EOL> if prim_vals . get ( i ) is not None : <EOL> cnt += prim_vals . get ( i ) <EOL> break <EOL> if is_prime ( i ) : <EOL> cnt += <NUM_LIT:1> <EOL> prim_vals [ num ] = cnt <EOL> print ( cnt ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
MAX = <NUM_LIT> <EOL> s = [ <NUM_LIT:1> ] * MAX <EOL> s [ <NUM_LIT:0> ] = <NUM_LIT:0> <EOL> s [ <NUM_LIT:1> ] = <NUM_LIT:0> <EOL> start = <NUM_LIT:2> <EOL> while True : <EOL> pmb = <NUM_LIT:0> <EOL> for i in range ( start , MAX ) : <EOL> if s [ i ] == <NUM_LIT:1> : <EOL> pmb = i <EOL> break <EOL> if pmb == <NUM_LIT:0> : <EOL> break <EOL> for i in range ( pmb ** <NUM_LIT:2> , MAX , pmb ) : <EOL> s [ i ] = <NUM_LIT:0> <EOL> start += <NUM_LIT:1> <EOL> while True : <EOL> try : <EOL> n = int ( input ( ) ) <EOL> c = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if s [ i ] == <NUM_LIT:1> : <EOL> c += <NUM_LIT:1> <EOL> print ( c ) <EOL> except EOFError : <EOL> break
def stl1 ( x ) : <EOL> if a == e : <EOL> y = b <EOL> else : <EOL> y = ( f - b ) * ( x - a ) / ( e - a ) + b <EOL> return ( y ) <EOL> def stl2 ( x ) : <EOL> if c == e : <EOL> y = f <EOL> else : <EOL> y = ( d - f ) * ( x - e ) / ( c - e ) + f <EOL> return ( y ) <EOL> def stl3 ( x ) : <EOL> if c == a : <EOL> y = b <EOL> else : <EOL> y = ( d - b ) * ( x - a ) / ( c - a ) + b <EOL> return ( y ) <EOL> while True : <EOL> try : <EOL> lst = list ( map ( float , input ( ) . split ( ) ) ) <EOL> point1 = [ lst [ <NUM_LIT:0> ] , lst [ <NUM_LIT:1> ] ] <EOL> point2 = [ lst [ <NUM_LIT:2> ] , lst [ <NUM_LIT:3> ] ] <EOL> point3 = [ lst [ <NUM_LIT:4> ] , lst [ <NUM_LIT:5> ] ] <EOL> xp , yp = lst [ <NUM_LIT:6> ] , lst [ <NUM_LIT:7> ] <EOL> pointlst = [ point1 , point2 , point3 ] <EOL> pointlst . sort ( ) <EOL> a , b , e , f , c , d = pointlst [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , pointlst [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] , pointlst [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , pointlst [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] , pointlst [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , pointlst [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] <EOL> if a <= xp and xp <= e : <EOL> bdr1 = stl1 ( xp ) <EOL> bdr3 = stl3 ( xp ) <EOL> if min ( bdr1 , bdr3 ) <= yp and yp <= max ( bdr1 , bdr3 ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" ) <EOL> elif e < xp and xp <= c : <EOL> bdr2 = stl2 ( xp ) <EOL> bdr3 = stl3 ( xp ) <EOL> if min ( bdr2 , bdr3 ) <= yp and yp <= max ( bdr2 , bdr3 ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" ) <EOL> except EOFError : <EOL> break
import sys , re <EOL> from collections import deque , defaultdict , Counter <EOL> from math import ceil , sqrt , hypot , factorial , pi , sin , cos , radians <EOL> from itertools import permutations , combinations , product <EOL> from operator import itemgetter , mul <EOL> from copy import deepcopy <EOL> from string import ascii_lowercase , ascii_uppercase , digits <EOL> from fractions import gcd <EOL> from bisect import bisect_left <EOL> from heapq import heappush , heappop <EOL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <EOL> def INT ( ) : return int ( input ( ) ) <EOL> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <EOL> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <EOL> sys . setrecursionlimit ( <NUM_LIT:10> ** <NUM_LIT:9> ) <EOL> INF = float ( '<STR_LIT>' ) <EOL> mod = <NUM_LIT:10> ** <NUM_LIT:9> + <NUM_LIT:7> <EOL> def primes_for ( n ) : <EOL> is_prime = [ True ] * ( n + <NUM_LIT:1> ) <EOL> is_prime [ <NUM_LIT:0> ] = False <EOL> is_prime [ <NUM_LIT:1> ] = False <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> for j in range ( i * <NUM_LIT:2> , n + <NUM_LIT:1> , i ) : <EOL> is_prime [ j ] = False <EOL> return [ i for i in range ( n + <NUM_LIT:1> ) if is_prime [ i ] ] <EOL> prime_list = primes_for ( <NUM_LIT:10> ** <NUM_LIT:6> ) <EOL> is_prime = [ <NUM_LIT:0> ] * <NUM_LIT:10> ** <NUM_LIT:6> <EOL> for n in prime_list : <EOL> is_prime [ n ] = <NUM_LIT:1> <EOL> cnt = [ <NUM_LIT:0> ] * <NUM_LIT:10> ** <NUM_LIT:6> <EOL> for i in range ( <NUM_LIT:2> , <NUM_LIT:10> ** <NUM_LIT:6> ) : <EOL> if is_prime [ i ] : <EOL> cnt [ i ] = cnt [ i - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> else : <EOL> cnt [ i ] = cnt [ i - <NUM_LIT:1> ] <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> n = INT ( ) <EOL> print ( cnt [ n ] ) <EOL> except : <EOL> sys . exit ( )
import sys <EOL> class Point ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . x = x <EOL> self . y = y <EOL> def isLeft ( self , vector ) : <EOL> tmpVector = DirectedVector ( vector . start , self ) <EOL> sin = tmpVector * vector <EOL> if sin > <NUM_LIT:0> : <EOL> return True <EOL> else : <EOL> return False <EOL> class DirectedVector ( object ) : <EOL> def __init__ ( self , start , end ) : <EOL> self . start = start <EOL> self . end = end <EOL> @ property <EOL> def x ( self ) : <EOL> return self . end . x - self . start . x <EOL> @ property <EOL> def y ( self ) : <EOL> return self . end . y - self . start . y <EOL> def __mul__ ( self , other ) : <EOL> return self . x * other . y - self . y * other . x <EOL> def getDataSets ( ) : <EOL> for line in sys . stdin . readlines ( ) : <EOL> line = line . strip ( ) <EOL> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = [ float ( x ) for x in line . split ( ) ] <EOL> p1 = Point ( x1 , y1 ) <EOL> p2 = Point ( x2 , y2 ) <EOL> p3 = Point ( x3 , y3 ) <EOL> px = Point ( xp , yp ) <EOL> yield p1 , p2 , p3 , px <EOL> def main ( ) : <EOL> for p1 , p2 , p3 , px in getDataSets ( ) : <EOL> evaluate = [ <EOL> px . isLeft ( DirectedVector ( p1 , p2 ) ) , <EOL> px . isLeft ( DirectedVector ( p2 , p3 ) ) , <EOL> px . isLeft ( DirectedVector ( p3 , p1 ) ) , <EOL> ] <EOL> if ( all ( evaluate ) or not any ( evaluate ) ) : <EOL> print '<STR_LIT>' <EOL> else : <EOL> print '<STR_LIT>' <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( )
def direction_vector ( p1 : list , p2 : list ) -> list : <EOL> return [ p2 [ <NUM_LIT:0> ] - p1 [ <NUM_LIT:0> ] , p2 [ <NUM_LIT:1> ] - p1 [ <NUM_LIT:1> ] ] <EOL> def cross_product ( v1 : list , v2 : list ) -> float : <EOL> return v1 [ <NUM_LIT:0> ] * v2 [ <NUM_LIT:1> ] - v1 [ <NUM_LIT:1> ] * v2 [ <NUM_LIT:0> ] <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> while True : <EOL> try : <EOL> points_receive = list ( map ( float , input ( ) . split ( ) ) ) <EOL> except EOFError : <EOL> break <EOL> points_list = [ [ points_receive [ <NUM_LIT:2> * i ] , points_receive [ <NUM_LIT:2> * i + <NUM_LIT:1> ] ] for i in range ( <NUM_LIT:4> ) ] <EOL> p1_to_p2 = direction_vector ( points_list [ <NUM_LIT:0> ] , points_list [ <NUM_LIT:1> ] ) <EOL> p2_to_p3 = direction_vector ( points_list [ <NUM_LIT:1> ] , points_list [ <NUM_LIT:2> ] ) <EOL> p3_to_p1 = direction_vector ( points_list [ <NUM_LIT:2> ] , points_list [ <NUM_LIT:0> ] ) <EOL> p1_to_pp = direction_vector ( points_list [ <NUM_LIT:0> ] , points_list [ <NUM_LIT:3> ] ) <EOL> p2_to_pp = direction_vector ( points_list [ <NUM_LIT:1> ] , points_list [ <NUM_LIT:3> ] ) <EOL> p3_to_pp = direction_vector ( points_list [ <NUM_LIT:2> ] , points_list [ <NUM_LIT:3> ] ) <EOL> cp1 = cross_product ( p1_to_p2 , p1_to_pp ) <EOL> cp2 = cross_product ( p2_to_p3 , p2_to_pp ) <EOL> cp3 = cross_product ( p3_to_p1 , p3_to_pp ) <EOL> if cp1 > <NUM_LIT:0> and cp2 > <NUM_LIT:0> and cp3 > <NUM_LIT:0> : <EOL> print ( '<STR_LIT>' ) <EOL> elif cp1 < <NUM_LIT:0> and cp2 < <NUM_LIT:0> and cp3 < <NUM_LIT:0> : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' )
import sys <EOL> SIZE = <NUM_LIT:10> <EOL> paper = [ ] <EOL> def main ( ) : <EOL> init ( ) <EOL> for line in sys . stdin : <EOL> data = line . strip ( ) . split ( '<STR_LIT:U+002C>' ) <EOL> i = int ( data [ <NUM_LIT:0> ] ) <EOL> j = int ( data [ <NUM_LIT:1> ] ) <EOL> size = int ( data [ <NUM_LIT:2> ] ) <EOL> if size == <NUM_LIT:1> : <EOL> drop_small ( i , j ) <EOL> elif size == <NUM_LIT:2> : <EOL> drop_medium ( i , j ) <EOL> elif size == <NUM_LIT:3> : <EOL> drop_large ( i , j ) <EOL> print count_white ( ) <EOL> print find_max ( ) <EOL> def find_max ( ) : <EOL> mx = <NUM_LIT:0> <EOL> for i in xrange ( SIZE ) : <EOL> for j in xrange ( SIZE ) : <EOL> mx = max ( mx , paper [ i ] [ j ] ) <EOL> return mx <EOL> def count_white ( ) : <EOL> c = <NUM_LIT:0> <EOL> for i in xrange ( SIZE ) : <EOL> for j in xrange ( SIZE ) : <EOL> if paper [ i ] [ j ] == <NUM_LIT:0> : <EOL> c += <NUM_LIT:1> <EOL> return c <EOL> def init ( ) : <EOL> global paper <EOL> for i in xrange ( SIZE ) : <EOL> paper . append ( [ <NUM_LIT:0> ] * SIZE ) <EOL> def check ( i , j ) : <EOL> if i < <NUM_LIT:0> or SIZE <= i : <EOL> return False <EOL> if j < <NUM_LIT:0> or SIZE <= j : <EOL> return False <EOL> return True <EOL> def drop ( i , j ) : <EOL> global paper <EOL> if not check ( i , j ) : <EOL> return False <EOL> paper [ i ] [ j ] += <NUM_LIT:1> <EOL> return True <EOL> def drop_small ( i , j ) : <EOL> drop ( i , j ) <EOL> drop ( i - <NUM_LIT:1> , j ) <EOL> drop ( i + <NUM_LIT:1> , j ) <EOL> drop ( i , j - <NUM_LIT:1> ) <EOL> drop ( i , j + <NUM_LIT:1> ) <EOL> def drop_medium ( i , j ) : <EOL> drop_small ( i , j ) <EOL> drop ( i - <NUM_LIT:1> , j - <NUM_LIT:1> ) <EOL> drop ( i - <NUM_LIT:1> , j + <NUM_LIT:1> ) <EOL> drop ( i + <NUM_LIT:1> , j - <NUM_LIT:1> ) <EOL> drop ( i + <NUM_LIT:1> , j + <NUM_LIT:1> ) <EOL> def drop_large ( i , j ) : <EOL> drop_medium ( i , j ) <EOL> drop ( i - <NUM_LIT:2> , j ) <EOL> drop ( i , j - <NUM_LIT:2> ) <EOL> drop ( i , j + <NUM_LIT:2> ) <EOL> drop ( i + <NUM_LIT:2> , j ) <EOL> main ( )
a = [ [ <NUM_LIT:0> for i2 in range ( <NUM_LIT:10> ) ] for i1 in range ( <NUM_LIT:10> ) ] <EOL> def small_ink ( x , y ) : <EOL> a [ x ] [ y ] += <NUM_LIT:1> <EOL> a [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> try : <EOL> a [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> except : <EOL> pass <EOL> a [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> try : <EOL> a [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> except : <EOL> pass <EOL> if x - <NUM_LIT:1> < <NUM_LIT:0> : <EOL> a [ x - <NUM_LIT:1> ] [ y ] -= <NUM_LIT:1> <EOL> if y - <NUM_LIT:1> < <NUM_LIT:0> : <EOL> a [ x ] [ y - <NUM_LIT:1> ] -= <NUM_LIT:1> <EOL> return <NUM_LIT:0> <EOL> def mid_ink ( x , y ) : <EOL> for i in [ - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ] : <EOL> for j in [ - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ] : <EOL> if <NUM_LIT:9> >= x + i >= <NUM_LIT:0> and <NUM_LIT:9> >= y + j >= <NUM_LIT:0> : <EOL> a [ x + i ] [ y + j ] += <NUM_LIT:1> <EOL> return <NUM_LIT:0> <EOL> def big_ink ( x , y ) : <EOL> mid_ink ( x , y ) <EOL> a [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> try : <EOL> a [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> except : <EOL> pass <EOL> a [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> try : <EOL> a [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> except : <EOL> pass <EOL> if x - <NUM_LIT:2> < <NUM_LIT:0> : <EOL> a [ x - <NUM_LIT:2> ] [ y ] -= <NUM_LIT:1> <EOL> if y - <NUM_LIT:2> < <NUM_LIT:0> : <EOL> a [ x ] [ y - <NUM_LIT:2> ] -= <NUM_LIT:1> <EOL> return <NUM_LIT:0> <EOL> def ink ( x , y , s ) : <EOL> if s == <NUM_LIT:1> : <EOL> small_ink ( x , y ) <EOL> if s == <NUM_LIT:2> : <EOL> mid_ink ( x , y ) <EOL> if s == <NUM_LIT:3> : <EOL> big_ink ( x , y ) <EOL> return <NUM_LIT:0> <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( '<STR_LIT:U+002C>' ) ) <EOL> ink ( x , y , s ) <EOL> except EOFError : <EOL> break <EOL> nu = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if a [ i ] [ j ] == <NUM_LIT:0> : <EOL> nu += <NUM_LIT:1> <EOL> print ( nu ) <EOL> max_val = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if a [ i ] [ j ] > max_val : <EOL> max_val = a [ i ] [ j ] <EOL> print ( max_val )
import sys <EOL> table = [ [ <NUM_LIT:0> for j in range ( <NUM_LIT:10> ) ] for i in range ( <NUM_LIT:10> ) ] <EOL> def flag ( x , y ) : <EOL> if x > <NUM_LIT:9> or y > <NUM_LIT:9> or x < <NUM_LIT:0> or y < <NUM_LIT:0> : <EOL> return False <EOL> else : <EOL> return True <EOL> def small ( x , y ) : <EOL> table [ x ] [ y ] += <NUM_LIT:1> <EOL> if flag ( x + <NUM_LIT:1> , y ) : <EOL> table [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if flag ( x - <NUM_LIT:1> , y ) : <EOL> table [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if flag ( x , y + <NUM_LIT:1> ) : <EOL> table [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if flag ( x , y - <NUM_LIT:1> ) : <EOL> table [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def medium ( x , y ) : <EOL> small ( x , y ) <EOL> if flag ( x + <NUM_LIT:1> , y + <NUM_LIT:1> ) : <EOL> table [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if flag ( x + <NUM_LIT:1> , y - <NUM_LIT:1> ) : <EOL> table [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if flag ( x - <NUM_LIT:1> , y + <NUM_LIT:1> ) : <EOL> table [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if flag ( x - <NUM_LIT:1> , y - <NUM_LIT:1> ) : <EOL> table [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def large ( x , y ) : <EOL> medium ( x , y ) <EOL> if flag ( x + <NUM_LIT:2> , y ) : <EOL> table [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if flag ( x - <NUM_LIT:2> , y ) : <EOL> table [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if flag ( x , y + <NUM_LIT:2> ) : <EOL> table [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if flag ( x , y - <NUM_LIT:2> ) : <EOL> table [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> def ink ( x , y , s ) : <EOL> if s == <NUM_LIT:1> : <EOL> small ( x , y ) <EOL> if s == <NUM_LIT:2> : <EOL> medium ( x , y ) <EOL> if s == <NUM_LIT:3> : <EOL> large ( x , y ) <EOL> def Search ( ) : <EOL> counter = <NUM_LIT:0> <EOL> thickest = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if table [ i ] [ j ] == <NUM_LIT:0> : <EOL> counter += <NUM_LIT:1> <EOL> elif thickest < table [ i ] [ j ] : <EOL> thickest = table [ i ] [ j ] <EOL> print ( counter ) <EOL> print ( thickest ) <EOL> for l in sys . stdin : <EOL> data = list ( map ( int , l . split ( "<STR_LIT:U+002C>" ) ) ) <EOL> x , y , s = data <EOL> ink ( x , y , s ) <EOL> Search ( )
import sys <EOL> def small_inc ( x , y , cells ) : <EOL> cells [ x ] [ y ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:0> : <EOL> cells [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if y < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def medium_inc ( x , y , cells ) : <EOL> if y > <NUM_LIT:0> : <EOL> cells [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> cells [ x ] [ y ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if y < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def large_inc ( x , y , cells ) : <EOL> if y > <NUM_LIT:1> : <EOL> cells [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:0> : <EOL> cells [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> cells [ x ] [ y ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:1> : <EOL> cells [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:2> : <EOL> cells [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if y < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> cells [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < MAPSIZE - <NUM_LIT:1> : <EOL> cells [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y < MAPSIZE - <NUM_LIT:2> : <EOL> cells [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> SMALL = <NUM_LIT:1> <EOL> MEDIUM = <NUM_LIT:2> <EOL> LARGE = <NUM_LIT:3> <EOL> MAPSIZE = <NUM_LIT:10> <EOL> cells = [ [ <NUM_LIT:0> for i in range ( MAPSIZE ) ] for j in range ( MAPSIZE ) ] <EOL> for line in sys . stdin : <EOL> x , y , size = map ( int , line . split ( '<STR_LIT:U+002C>' ) ) <EOL> if size == SMALL : <EOL> small_inc ( x , y , cells ) <EOL> elif size == MEDIUM : <EOL> medium_inc ( x , y , cells ) <EOL> elif size == LARGE : <EOL> large_inc ( x , y , cells ) <EOL> count = max_d = <NUM_LIT:0> <EOL> for i in range ( MAPSIZE ) : <EOL> for j in range ( MAPSIZE ) : <EOL> if cells [ i ] [ j ] == <NUM_LIT:0> : <EOL> count += <NUM_LIT:1> <EOL> else : <EOL> max_d = max ( max_d , cells [ i ] [ j ] ) <EOL> print count <EOL> print max_d
import sys <EOL> alpha = '<STR_LIT>' <EOL> def this ( word ) : <EOL> i = <NUM_LIT:0> <EOL> t = [ ] <EOL> for c in word : <EOL> x = ord ( c ) - ord ( '<STR_LIT>' [ i ] ) <EOL> if x >= <NUM_LIT:0> : <EOL> t . append ( x ) <EOL> else : <EOL> t . append ( <NUM_LIT> + x ) <EOL> i += <NUM_LIT:1> <EOL> if ( t [ <NUM_LIT:0> ] == t [ <NUM_LIT:1> ] and t [ <NUM_LIT:1> ] == t [ <NUM_LIT:2> ] and t [ <NUM_LIT:2> ] == t [ <NUM_LIT:3> ] ) : <EOL> return t [ <NUM_LIT:0> ] <EOL> return <NUM_LIT:30> <EOL> def that ( word ) : <EOL> i = <NUM_LIT:0> <EOL> t = [ ] <EOL> for c in word : <EOL> x = ord ( c ) - ord ( '<STR_LIT>' [ i ] ) <EOL> if x >= <NUM_LIT:0> : <EOL> t . append ( x ) <EOL> else : <EOL> t . append ( <NUM_LIT> + x ) <EOL> i += <NUM_LIT:1> <EOL> if ( t [ <NUM_LIT:0> ] == t [ <NUM_LIT:1> ] and t [ <NUM_LIT:1> ] == t [ <NUM_LIT:2> ] and t [ <NUM_LIT:2> ] == t [ <NUM_LIT:3> ] ) : <EOL> return t [ <NUM_LIT:0> ] <EOL> return <NUM_LIT:30> <EOL> def the ( word ) : <EOL> i = <NUM_LIT:0> <EOL> t = [ ] <EOL> for c in word : <EOL> x = ord ( c ) - ord ( '<STR_LIT>' [ i ] ) <EOL> if x >= <NUM_LIT:0> : <EOL> t . append ( x ) <EOL> else : <EOL> t . append ( <NUM_LIT> + x ) <EOL> i += <NUM_LIT:1> <EOL> if ( t [ <NUM_LIT:0> ] == t [ <NUM_LIT:1> ] and t [ <NUM_LIT:1> ] == t [ <NUM_LIT:2> ] ) : <EOL> return t [ <NUM_LIT:0> ] <EOL> return <NUM_LIT:30> <EOL> for string in sys . stdin : <EOL> for word in string . split ( "<STR_LIT:U+0020>" ) : <EOL> if ( len ( word ) == <NUM_LIT:3> ) : <EOL> if the ( word ) < <NUM_LIT:30> : <EOL> x = the ( word ) <EOL> break <EOL> if ( len ( word ) == <NUM_LIT:4> ) : <EOL> if this ( word ) < <NUM_LIT:30> : <EOL> x = this ( word ) <EOL> break <EOL> if that ( word ) < <NUM_LIT:30> : <EOL> x = that ( word ) <EOL> break <EOL> result = "<STR_LIT>" <EOL> for c in string : <EOL> if c in alpha : <EOL> result += alpha [ alpha . find ( c ) - x ] <EOL> else : <EOL> result += c <EOL> print result [ : - <NUM_LIT:1> ]
if __name__ == '<STR_LIT:__main__>' : <EOL> DI = [ [ <NUM_LIT:0> for _ in range ( <NUM_LIT:10> ) ] for _ in range ( <NUM_LIT:10> ) ] <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if s == <NUM_LIT:0> : <EOL> break <EOL> if s == <NUM_LIT:1> : <EOL> DI [ x ] [ y ] += <NUM_LIT:1> <EOL> if y >= <NUM_LIT:1> : <EOL> DI [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y <= <NUM_LIT:8> : <EOL> DI [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> : <EOL> DI [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> : <EOL> DI [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> elif s == <NUM_LIT:2> : <EOL> DI [ x ] [ y ] += <NUM_LIT:1> <EOL> if y >= <NUM_LIT:1> : <EOL> DI [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> and y >= <NUM_LIT:1> : <EOL> DI [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> and y >= <NUM_LIT:1> : <EOL> DI [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y <= <NUM_LIT:8> : <EOL> DI [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> and y <= <NUM_LIT:8> : <EOL> DI [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> and y <= <NUM_LIT:8> : <EOL> DI [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> : <EOL> DI [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> : <EOL> DI [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> else : <EOL> DI [ x ] [ y ] += <NUM_LIT:1> <EOL> if y >= <NUM_LIT:1> : <EOL> DI [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> and y >= <NUM_LIT:1> : <EOL> DI [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> and y >= <NUM_LIT:1> : <EOL> DI [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y >= <NUM_LIT:2> : <EOL> DI [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if y <= <NUM_LIT:8> : <EOL> DI [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> and y <= <NUM_LIT:8> : <EOL> DI [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> and y <= <NUM_LIT:8> : <EOL> DI [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y <= <NUM_LIT:7> : <EOL> DI [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:1> : <EOL> DI [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x >= <NUM_LIT:2> : <EOL> DI [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:8> : <EOL> DI [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if x <= <NUM_LIT:7> : <EOL> DI [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> except EOFError : <EOL> break <EOL> cnt = <NUM_LIT:0> <EOL> maxcnt = <NUM_LIT:0> <EOL> for k in DI : <EOL> cnt += k . count ( <NUM_LIT:0> ) <EOL> if maxcnt < max ( k ) : <EOL> maxcnt = max ( k ) <EOL> print ( cnt ) <EOL> print ( maxcnt )
p = [ [ <NUM_LIT:0> for i in range ( <NUM_LIT> ) ] for j in range ( <NUM_LIT> ) ] <EOL> while True : <EOL> try : <EOL> x_inp , y_inp , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> x = x_inp + <NUM_LIT:2> <EOL> y = y_inp + <NUM_LIT:2> <EOL> if s == <NUM_LIT:1> : <EOL> p [ y - <NUM_LIT:1> ] [ x ] = p [ y - <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> p [ y ] [ x - <NUM_LIT:1> ] = p [ y ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x ] = p [ y ] [ x ] + <NUM_LIT:1> <EOL> p [ y ] [ x + <NUM_LIT:1> ] = p [ y ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x ] = p [ y + <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> elif s == <NUM_LIT:2> : <EOL> p [ y - <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] = p [ y - <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y - <NUM_LIT:1> ] [ x ] = p [ y - <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> p [ y - <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] = p [ y - <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x - <NUM_LIT:1> ] = p [ y ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x ] = p [ y ] [ x ] + <NUM_LIT:1> <EOL> p [ y ] [ x + <NUM_LIT:1> ] = p [ y ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] = p [ y + <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x ] = p [ y + <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] = p [ y + <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> else : <EOL> p [ y - <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> p [ y - <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] = p [ y - <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y - <NUM_LIT:1> ] [ x ] = p [ y - <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> p [ y - <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] = p [ y - <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x - <NUM_LIT:2> ] = p [ y ] [ x - <NUM_LIT:2> ] + <NUM_LIT:1> <EOL> p [ y ] [ x - <NUM_LIT:1> ] = p [ y ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x ] = p [ y ] [ x ] + <NUM_LIT:1> <EOL> p [ y ] [ x + <NUM_LIT:1> ] = p [ y ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y ] [ x + <NUM_LIT:2> ] = p [ y ] [ x + <NUM_LIT:2> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] = p [ y + <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x ] = p [ y + <NUM_LIT:1> ] [ x ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] = p [ y + <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] + <NUM_LIT:1> <EOL> p [ y + <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> except : <EOL> break <EOL> p_trim = [ p [ i ] [ <NUM_LIT:2> : <NUM_LIT:12> ] for i in range ( <NUM_LIT:2> , <NUM_LIT:12> ) ] <EOL> p_flatten = sum ( p_trim , [ ] ) <EOL> print ( sum ( x == <NUM_LIT:0> for x in p_flatten ) ) <EOL> print ( max ( p_flatten ) )
import sys <EOL> def main ( ) : <EOL> data = [ ] <EOL> lines = sys . stdin . readlines ( ) <EOL> for line in lines : <EOL> data . append ( line . split ( ) ) <EOL> N = len ( data ) <EOL> for i in range ( N ) : <EOL> for k in range ( <NUM_LIT:6> ) : <EOL> data [ i ] [ k ] = int ( data [ i ] [ k ] ) <EOL> det = data [ i ] [ <NUM_LIT:0> ] * data [ i ] [ <NUM_LIT:4> ] - data [ i ] [ <NUM_LIT:1> ] * data [ i ] [ <NUM_LIT:3> ] <EOL> gx = data [ i ] [ <NUM_LIT:2> ] * data [ i ] [ <NUM_LIT:4> ] - data [ i ] [ <NUM_LIT:1> ] * data [ i ] [ <NUM_LIT:5> ] <EOL> gy = data [ i ] [ <NUM_LIT:0> ] * data [ i ] [ <NUM_LIT:5> ] - data [ i ] [ <NUM_LIT:2> ] * data [ i ] [ <NUM_LIT:3> ] <EOL> if det < <NUM_LIT:0> : <EOL> det = - det ; <EOL> if gx != <NUM_LIT:0> : gx = - gx <EOL> if gy != <NUM_LIT:0> : gy = - gy <EOL> print ( "<STR_LIT>" . format ( gx / det ) + "<STR_LIT:U+0020>" + "<STR_LIT>" . format ( gy / det ) ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( )
def check ( x , y ) : <EOL> return <NUM_LIT:0> <= x <= <NUM_LIT:9> and <NUM_LIT:0> <= y <= <NUM_LIT:9> <EOL> def small ( x , y , area ) : <EOL> if check ( x + <NUM_LIT:1> , y ) : <EOL> area [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if check ( x , y + <NUM_LIT:1> ) : <EOL> area [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if check ( x - <NUM_LIT:1> , y ) : <EOL> area [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if check ( x , y - <NUM_LIT:1> ) : <EOL> area [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> area [ x ] [ y ] += <NUM_LIT:1> <EOL> return area <EOL> def mediam ( x , y , area ) : <EOL> area = small ( x , y , area ) <EOL> if check ( x + <NUM_LIT:1> , y + <NUM_LIT:1> ) : <EOL> area [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if check ( x + <NUM_LIT:1> , y - <NUM_LIT:1> ) : <EOL> area [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if check ( x - <NUM_LIT:1> , y + <NUM_LIT:1> ) : <EOL> area [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if check ( x - <NUM_LIT:1> , y - <NUM_LIT:1> ) : <EOL> area [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> return area <EOL> def large ( x , y , area ) : <EOL> area = mediam ( x , y , area ) <EOL> if check ( x + <NUM_LIT:2> , y ) : <EOL> area [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if check ( x , y + <NUM_LIT:2> ) : <EOL> area [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if check ( x - <NUM_LIT:2> , y ) : <EOL> area [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if check ( x , y - <NUM_LIT:2> ) : <EOL> area [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> return area <EOL> area = [ [ <NUM_LIT:0> for i in range ( <NUM_LIT:10> ) ] for j in range ( <NUM_LIT:10> ) ] <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( '<STR_LIT:U+002C>' ) ) <EOL> except : <EOL> break <EOL> if s == <NUM_LIT:1> : <EOL> area = small ( x , y , area ) <EOL> if s == <NUM_LIT:2> : <EOL> area = mediam ( x , y , area ) <EOL> if s == <NUM_LIT:3> : <EOL> area = large ( x , y , area ) <EOL> max = <NUM_LIT:0> <EOL> cnt = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if area [ i ] [ j ] == <NUM_LIT:0> : <EOL> cnt += <NUM_LIT:1> <EOL> if area [ i ] [ j ] > max : <EOL> max = area [ i ] [ j ] <EOL> print ( cnt ) <EOL> print ( max )
paper = [ [ <NUM_LIT:0> for i in range ( <NUM_LIT:10> ) ] for j in range ( <NUM_LIT:10> ) ] <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> paper [ x ] [ y ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> paper [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:0> : <EOL> paper [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:9> : <EOL> paper [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:9> : <EOL> paper [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if s > <NUM_LIT:1> : <EOL> if x > <NUM_LIT:0> : <EOL> if y > <NUM_LIT:0> : <EOL> paper [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:9> : <EOL> paper [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:9> : <EOL> if y > <NUM_LIT:0> : <EOL> paper [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:9> : <EOL> paper [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if s > <NUM_LIT:2> : <EOL> if x > <NUM_LIT:1> : <EOL> paper [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:1> : <EOL> paper [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:8> : <EOL> paper [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:8> : <EOL> paper [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> except EOFError : <EOL> break <EOL> S = <NUM_LIT:0> <EOL> M = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if paper [ i ] [ j ] == <NUM_LIT:0> : <EOL> S += <NUM_LIT:1> <EOL> if paper [ i ] [ j ] > M : <EOL> M = paper [ i ] [ j ] <EOL> print ( S ) <EOL> print ( M )
E = <NUM_LIT:10> ** - <NUM_LIT:10> <EOL> def cp ( a , b ) : <EOL> c = [ a [ <NUM_LIT:1> ] * b [ <NUM_LIT:2> ] - a [ <NUM_LIT:2> ] * b [ <NUM_LIT:1> ] , <EOL> a [ <NUM_LIT:2> ] * b [ <NUM_LIT:0> ] - a [ <NUM_LIT:0> ] * b [ <NUM_LIT:2> ] , <EOL> a [ <NUM_LIT:0> ] * b [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] * b [ <NUM_LIT:0> ] ] <EOL> return c <EOL> while True : <EOL> try : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = [ float ( i ) for i in input ( ) . split ( ) ] <EOL> ax = x3 - x1 <EOL> ay = y3 - y1 <EOL> bx = x1 - x2 <EOL> by = y1 - y2 <EOL> cx = x2 - x3 <EOL> cy = y2 - y3 <EOL> pax = xp - x1 <EOL> pay = yp - y1 <EOL> pbx = xp - x2 <EOL> pby = yp - y2 <EOL> pcx = xp - x3 <EOL> pcy = yp - y3 <EOL> ca = [ bx , by , <NUM_LIT:0> ] <EOL> ab = [ cx , cy , <NUM_LIT:0> ] <EOL> bc = [ ax , ay , <NUM_LIT:0> ] <EOL> pa = [ pax , pay , <NUM_LIT:0> ] <EOL> pb = [ pbx , pby , <NUM_LIT:0> ] <EOL> pc = [ pcx , pcy , <NUM_LIT:0> ] <EOL> cp1 = cp ( ca , pa ) [ <NUM_LIT:2> ] <EOL> cp2 = cp ( ab , pb ) [ <NUM_LIT:2> ] <EOL> cp3 = cp ( bc , pc ) [ <NUM_LIT:2> ] <EOL> if abs ( cp1 - abs ( cp1 ) ) < E : <EOL> sig1 = <NUM_LIT:1> <EOL> elif abs ( cp1 + abs ( cp1 ) ) < E : <EOL> sig1 = - <NUM_LIT:1> <EOL> if abs ( cp2 - abs ( cp2 ) ) < E : <EOL> sig2 = <NUM_LIT:1> <EOL> elif abs ( cp2 + abs ( cp2 ) ) < E : <EOL> sig2 = - <NUM_LIT:1> <EOL> if abs ( cp3 - abs ( cp3 ) ) < E : <EOL> sig3 = <NUM_LIT:1> <EOL> elif abs ( cp3 + abs ( cp3 ) ) < E : <EOL> sig3 = - <NUM_LIT:1> <EOL> if abs ( sig1 + sig2 + sig3 ) == <NUM_LIT:3> : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> except EOFError : <EOL> break
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <EOL> sys . setrecursionlimit ( <NUM_LIT:10> ** <NUM_LIT:7> ) <EOL> inf = <NUM_LIT:10> ** <NUM_LIT:20> <EOL> eps = <NUM_LIT:1.0> / <NUM_LIT:10> ** <NUM_LIT> <EOL> mod = <NUM_LIT:10> ** <NUM_LIT:9> + <NUM_LIT:7> <EOL> dd = [ ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) ] <EOL> ddn = [ ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) ] <EOL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LI_ ( ) : return [ int ( x ) - <NUM_LIT:1> for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <EOL> def I ( ) : return int ( sys . stdin . readline ( ) ) <EOL> def F ( ) : return float ( sys . stdin . readline ( ) ) <EOL> def S ( ) : return input ( ) <EOL> def pf ( s ) : return print ( s , flush = True ) <EOL> def distance ( x1 , y1 , x2 , y2 ) : <EOL> return math . sqrt ( ( x1 - x2 ) ** <NUM_LIT:2> + ( y1 - y2 ) ** <NUM_LIT:2> ) <EOL> def intersection ( a1 , a2 , b1 , b2 ) : <EOL> x1 , y1 = a1 <EOL> x2 , y2 = a2 <EOL> x3 , y3 = b1 <EOL> x4 , y4 = b2 <EOL> ksi = ( y4 - y3 ) * ( x4 - x1 ) - ( x4 - x3 ) * ( y4 - y1 ) <EOL> eta = ( x2 - x1 ) * ( y4 - y1 ) - ( y2 - y1 ) * ( x4 - x1 ) <EOL> delta = ( x2 - x1 ) * ( y4 - y3 ) - ( y2 - y1 ) * ( x4 - x3 ) <EOL> if delta == <NUM_LIT:0> : <EOL> return None <EOL> ramda = ksi / delta ; <EOL> mu = eta / delta ; <EOL> if ramda >= <NUM_LIT:0> and ramda <= <NUM_LIT:1> and mu >= <NUM_LIT:0> and mu <= <NUM_LIT:1> : <EOL> return ( x1 + ramda * ( x2 - x1 ) , y1 + ramda * ( y2 - y1 ) ) <EOL> return None <EOL> def circumcenters ( a , b , c ) : <EOL> t1 = [ ( a [ <NUM_LIT:0> ] + b [ <NUM_LIT:0> ] ) / <NUM_LIT:2> , ( a [ <NUM_LIT:1> ] + b [ <NUM_LIT:1> ] ) / <NUM_LIT:2> ] <EOL> s1 = [ t1 [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] , a [ <NUM_LIT:0> ] - t1 [ <NUM_LIT:0> ] ] <EOL> t2 = [ ( a [ <NUM_LIT:0> ] + c [ <NUM_LIT:0> ] ) / <NUM_LIT:2> , ( a [ <NUM_LIT:1> ] + c [ <NUM_LIT:1> ] ) / <NUM_LIT:2> ] <EOL> s2 = [ t2 [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] , a [ <NUM_LIT:0> ] - t2 [ <NUM_LIT:0> ] ] <EOL> p1 = [ t1 [ <NUM_LIT:0> ] + s1 [ <NUM_LIT:0> ] * <NUM_LIT> , t1 [ <NUM_LIT:1> ] + s1 [ <NUM_LIT:1> ] * <NUM_LIT> ] <EOL> p2 = [ t1 [ <NUM_LIT:0> ] - s1 [ <NUM_LIT:0> ] * <NUM_LIT> , t1 [ <NUM_LIT:1> ] - s1 [ <NUM_LIT:1> ] * <NUM_LIT> ] <EOL> p3 = [ t2 [ <NUM_LIT:0> ] + s2 [ <NUM_LIT:0> ] * <NUM_LIT> , t2 [ <NUM_LIT:1> ] + s2 [ <NUM_LIT:1> ] * <NUM_LIT> ] <EOL> p4 = [ t2 [ <NUM_LIT:0> ] - s2 [ <NUM_LIT:0> ] * <NUM_LIT> , t2 [ <NUM_LIT:1> ] - s2 [ <NUM_LIT:1> ] * <NUM_LIT> ] <EOL> return intersection ( p1 , p2 , p3 , p4 ) <EOL> def main ( ) : <EOL> n = I ( ) <EOL> rr = [ ] <EOL> for _ in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = LF ( ) <EOL> a = [ x1 , y1 ] <EOL> b = [ x2 , y2 ] <EOL> c = [ x3 , y3 ] <EOL> t = circumcenters ( a , b , c ) <EOL> rr . append ( '<STR_LIT>' . format ( t [ <NUM_LIT:0> ] , t [ <NUM_LIT:1> ] , distance ( t [ <NUM_LIT:0> ] , t [ <NUM_LIT:1> ] , x1 , y1 ) ) ) <EOL> return '<STR_LIT:\n>' . join ( rr ) <EOL> print ( main ( ) )
import math <EOL> class P ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . x = x <EOL> self . y = y <EOL> def width ( self , p ) : <EOL> return math . sqrt ( ( self . x - p . x ) ** <NUM_LIT:2> + ( self . y - p . y ) ** <NUM_LIT:2> ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' . format ( self . x , self . y ) <EOL> def calc_cos ( a , b , c ) : <EOL> return ( b ** <NUM_LIT:2> + c ** <NUM_LIT:2> - a ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * c ) <EOL> def calc_sin ( c ) : <EOL> return math . sqrt ( <NUM_LIT:1> - c ** <NUM_LIT:2> ) <EOL> def calc_2sin ( s , c ) : <EOL> return <NUM_LIT:2> * s * c <EOL> def run ( ) : <EOL> n = int ( input ( ) ) <EOL> for _ in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = list ( map ( float , input ( ) . split ( ) ) ) <EOL> p1 , p2 , p3 = P ( x1 , y1 ) , P ( x2 , y2 ) , P ( x3 , y3 ) <EOL> a , b , c = p1 . width ( p2 ) , p2 . width ( p3 ) , p3 . width ( p1 ) <EOL> cosA , cosB , cosC = calc_cos ( a , b , c ) , calc_cos ( b , c , a ) , calc_cos ( c , a , b ) <EOL> sinA , sinB , sinC = calc_sin ( cosA ) , calc_sin ( cosB ) , calc_sin ( cosC ) <EOL> sin2A , sin2B , sin2C = calc_2sin ( sinA , cosA ) , calc_2sin ( sinB , cosB ) , calc_2sin ( sinC , cosC ) <EOL> r = a / sinA / <NUM_LIT:2> <EOL> x = ( p1 . x * sin2B + p2 . x * sin2C + p3 . x * sin2A ) / ( sin2A + sin2B + sin2C ) <EOL> y = ( p1 . y * sin2B + p2 . y * sin2C + p3 . y * sin2A ) / ( sin2A + sin2B + sin2C ) <EOL> print ( '<STR_LIT>' . format ( x , y , r ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> run ( )
import sys <EOL> def small ( grid , x , y ) : <EOL> grid [ x ] [ y ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> return grid <EOL> def middle ( grid , x , y ) : <EOL> grid [ x ] [ y ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> return grid <EOL> def large ( grid , x , y ) : <EOL> grid [ x ] [ y ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> grid [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> grid [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> grid [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> grid [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> return grid <EOL> grid = [ [ <NUM_LIT:0> for _ in range ( <NUM_LIT> ) ] for __ in range ( <NUM_LIT> ) ] <EOL> for line in sys . stdin : <EOL> d = list ( map ( int , line . split ( "<STR_LIT:U+002C>" ) ) ) <EOL> x = d [ <NUM_LIT:0> ] + <NUM_LIT:2> <EOL> y = d [ <NUM_LIT:1> ] + <NUM_LIT:2> <EOL> ink_size = d [ <NUM_LIT:2> ] <EOL> if ink_size == <NUM_LIT:1> : <EOL> grid = small ( grid , x , y ) <EOL> elif ink_size == <NUM_LIT:2> : <EOL> grid = middle ( grid , x , y ) <EOL> else : <EOL> grid = large ( grid , x , y ) <EOL> max_element = <NUM_LIT:0> <EOL> count = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> for j in range ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> max_element = max ( max_element , grid [ i ] [ j ] ) <EOL> if grid [ i ] [ j ] == <NUM_LIT:0> : <EOL> count += <NUM_LIT:1> <EOL> print ( count ) <EOL> print ( max_element )
import sys <EOL> import math <EOL> import array <EOL> class mymath : <EOL> pi = <NUM_LIT> <EOL> def pnum_eratosthenes ( self , n ) : <EOL> ptable = [ <NUM_LIT:0> for i in range ( n + <NUM_LIT:1> ) ] <EOL> plist = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if ptable [ i ] == <NUM_LIT:0> : <EOL> plist . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> ptable [ j ] = <NUM_LIT:1> <EOL> return plist <EOL> def pnum_fermat ( self , n ) : <EOL> pnum = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if i % <NUM_LIT:2> == <NUM_LIT:0> and i != <NUM_LIT:2> : <EOL> continue <EOL> if pow ( <NUM_LIT:2> , i - <NUM_LIT:1> , i ) == <NUM_LIT:1> : <EOL> pnum += <NUM_LIT:1> <EOL> return pnum <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> mymath = mymath ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> def main ( ) : <EOL> for line in sys . stdin . readlines ( ) : <EOL> n = int ( line ) <EOL> n_pn = mymath . pnum_eratosthenes ( n ) <EOL> print ( len ( n_pn ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
class Solution ( object ) : <EOL> def combinationSum ( self , target ) : <EOL> candidates = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> candidates . append ( i ) <EOL> stack = [ ( <NUM_LIT:0> , <NUM_LIT:0> , [ ] ) ] <EOL> result = [ ] <EOL> while stack : <EOL> total , start , res = stack . pop ( ) <EOL> if total == target and len ( res ) == <NUM_LIT:4> : <EOL> result . append ( res ) <EOL> elif len ( res ) > <NUM_LIT:4> : <EOL> continue <EOL> if total == <NUM_LIT:0> and len ( res ) == <NUM_LIT:4> : <EOL> continue <EOL> for i in range ( start , len ( candidates ) ) : <EOL> t = total + candidates [ i ] <EOL> if t > target : <EOL> break <EOL> stack . append ( ( t , i , res + [ candidates [ i ] ] ) ) <EOL> return result <EOL> def duplicated ( self , nums , i , j ) : <EOL> for t in range ( i , j ) : <EOL> if nums [ t ] == nums [ j ] : <EOL> return False <EOL> return True <EOL> def recursion ( self , nums , i , n , result ) : <EOL> if i == n - <NUM_LIT:1> : <EOL> temp = [ ] <EOL> for k in range ( <NUM_LIT:0> , n ) : <EOL> temp . append ( nums [ k ] ) <EOL> result . append ( temp ) <EOL> else : <EOL> for k in range ( i , n ) : <EOL> if self . duplicated ( nums , i , k ) : <EOL> temp = nums [ k ] <EOL> nums [ k ] = nums [ i ] <EOL> nums [ i ] = temp <EOL> self . recursion ( nums , i + <NUM_LIT:1> , n , result ) <EOL> temp = nums [ k ] <EOL> nums [ k ] = nums [ i ] <EOL> nums [ i ] = temp <EOL> def permuteUnique ( self , nums ) : <EOL> result = [ ] <EOL> self . recursion ( nums , <NUM_LIT:0> , len ( nums ) , result ) <EOL> return result <EOL> while True : <EOL> try : <EOL> n = int ( raw_input ( ) ) <EOL> s = Solution ( ) <EOL> combination = s . combinationSum ( n ) <EOL> m = <NUM_LIT:0> <EOL> for i in range ( len ( combination ) ) : <EOL> m += len ( s . permuteUnique ( combination [ i ] ) ) <EOL> print m <EOL> except ( EOFError ) : <EOL> break
import sys <EOL> import math <EOL> class mymath : <EOL> pi = <NUM_LIT> <EOL> def pnum_eratosthenes ( self , n ) : <EOL> ptable = [ <NUM_LIT:0> for i in range ( n + <NUM_LIT:1> ) ] <EOL> plist = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if ptable [ i ] == <NUM_LIT:0> : <EOL> plist . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> ptable [ j ] = <NUM_LIT:1> <EOL> return plist <EOL> def pnum_check ( self , n ) : <EOL> if ( n == <NUM_LIT:1> ) : <EOL> return False <EOL> elif ( n == <NUM_LIT:2> ) : <EOL> return True <EOL> else : <EOL> for x in range ( <NUM_LIT:2> , n ) : <EOL> if ( n % x == <NUM_LIT:0> ) : <EOL> return False <EOL> return True <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> def mul ( self , A , B ) : <EOL> ans = [ ] <EOL> for a in A : <EOL> c = <NUM_LIT:0> <EOL> for j , row in enumerate ( a ) : <EOL> c += row * B [ j ] <EOL> ans . append ( c ) <EOL> return ans <EOL> def is_integer ( self , n ) : <EOL> try : <EOL> float ( n ) <EOL> except ValueError : <EOL> return False <EOL> else : <EOL> return float ( n ) . is_integer ( ) <EOL> def dist ( self , A , B ) : <EOL> d = <NUM_LIT:0> <EOL> for i in range ( len ( A ) ) : <EOL> d += ( A [ i ] - B [ i ] ) ** <NUM_LIT:2> <EOL> d = d ** ( <NUM_LIT:1> / <NUM_LIT:2> ) <EOL> return d <EOL> def abs ( self , n ) : <EOL> if n >= <NUM_LIT:0> : <EOL> return n <EOL> else : <EOL> return - n <EOL> mymath = mymath ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> def printA ( A ) : <EOL> N = len ( A ) <EOL> for i , n in enumerate ( A ) : <EOL> print ( n , end = '<STR_LIT>' ) <EOL> if i != N - <NUM_LIT:1> : <EOL> print ( '<STR_LIT:U+0020>' , end = '<STR_LIT>' ) <EOL> print ( ) <EOL> def get_input ( ) : <EOL> N = [ ] <EOL> while True : <EOL> try : <EOL> N . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <EOL> except EOFError : <EOL> break <EOL> return N <EOL> s = input ( ) <EOL> print ( str . upper ( s ) )
import string <EOL> import sys <EOL> def check_exists ( word_set , rotate_dict , search ) : <EOL> for word in word_set : <EOL> rotated_word = '<STR_LIT>' . join ( rotate_dict [ s ] for s in word ) <EOL> if rotated_word == search : <EOL> return True <EOL> return False <EOL> for line in sys . stdin : <EOL> alphabets = string . ascii_lowercase <EOL> frequency = [ t [ <NUM_LIT:1> ] for t in sorted ( [ ( line . count ( s ) , ord ( s ) ) for s in alphabets ] , reverse = True ) ] <EOL> freq_chr_offset = ( <NUM_LIT:4> , <NUM_LIT:0> , <NUM_LIT> , <NUM_LIT:8> , <NUM_LIT> ) <EOL> ss = list ( map ( lambda word : word . strip ( '<STR_LIT>' ) , line . split ( ) ) ) <EOL> sl3 , sl4 = set ( s for s in ss if len ( s ) == <NUM_LIT:3> ) , set ( s for s in ss if len ( s ) == <NUM_LIT:4> ) <EOL> i , rotate_dict = <NUM_LIT:0> , None <EOL> for order in frequency : <EOL> for offset in freq_chr_offset : <EOL> i = <NUM_LIT> + offset - order <EOL> rotate_dict = { a : b for a , b in zip ( alphabets , alphabets [ i : ] + alphabets [ : i ] ) } <EOL> if ( check_exists ( sl3 , rotate_dict , '<STR_LIT>' ) <EOL> + check_exists ( sl4 , rotate_dict , '<STR_LIT>' ) <EOL> + check_exists ( sl4 , rotate_dict , '<STR_LIT>' ) ) > <NUM_LIT:0> : <EOL> break <EOL> else : <EOL> continue <EOL> break <EOL> print ( '<STR_LIT>' . join ( rotate_dict [ s ] if s . isalpha ( ) else s for s in line ) , end = '<STR_LIT>' )
while <NUM_LIT:1> : <EOL> try : <EOL> n = int ( input ( ) ) <EOL> except : break <EOL> if ( n == <NUM_LIT:0> ) : break <EOL> sum = <NUM_LIT:0> <EOL> arr = [ ] <EOL> isPlus = True <EOL> maxValue = - <NUM_LIT> <EOL> for i in range ( n ) : <EOL> try : <EOL> arr . append ( int ( input ( ) ) ) <EOL> except : break <EOL> if arr [ i ] < <NUM_LIT:0> : <EOL> if sum > <NUM_LIT:0> : <EOL> if ( isPlus ) : <EOL> maxValue = max ( maxValue , sum ) <EOL> isPlus = False <EOL> sum += arr [ i ] <EOL> if sum < <NUM_LIT:0> : <EOL> sum = <NUM_LIT:0> <EOL> else : <EOL> sum += arr [ i ] <EOL> isPlus = True <EOL> if sum != <NUM_LIT:0> : <EOL> maxValue = max ( maxValue , sum ) <EOL> else : <EOL> for i in arr : <EOL> maxValue = max ( maxValue , i ) <EOL> print ( maxValue )
import sys <EOL> import math <EOL> prim_no = { <NUM_LIT:2> : True } <EOL> def is_prime ( no ) : <EOL> if no == <NUM_LIT:2> or no == <NUM_LIT:1> : <EOL> return True <EOL> if no % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> return False <EOL> if prim_no . get ( no ) is not None : <EOL> return prim_no . get ( no ) <EOL> max_check = int ( math . sqrt ( no ) ) <EOL> for i in range ( <NUM_LIT:3> , max_check + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if no % i == <NUM_LIT:0> : <EOL> prim_no [ no ] = False <EOL> return False <EOL> prim_no [ no ] = True <EOL> return True <EOL> def main ( ) : <EOL> prim_vals = { } <EOL> num_data = [ ] <EOL> while True : <EOL> num = sys . stdin . readline ( ) <EOL> if num is None or num . strip ( ) == '<STR_LIT>' : <EOL> break <EOL> num = int ( num . strip ( ) ) <EOL> num_data . append ( num ) <EOL> sorted_num_data = sorted ( num_data ) <EOL> prim_num = { } <EOL> for num in sorted_num_data : <EOL> if prim_vals . get ( num ) is not None : <EOL> cnt = prim_vals . get ( num ) <EOL> else : <EOL> if num == <NUM_LIT:1> : <EOL> cnt = <NUM_LIT:0> <EOL> else : <EOL> cnt = <NUM_LIT:0> <EOL> if num % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> start_num = num - <NUM_LIT:1> <EOL> else : <EOL> start_num = num <EOL> for i in range ( start_num , <NUM_LIT:0> , - <NUM_LIT:2> ) : <EOL> if prim_vals . get ( i ) is not None : <EOL> cnt += prim_vals . get ( i ) <EOL> break <EOL> if is_prime ( i ) : <EOL> cnt += <NUM_LIT:1> <EOL> prim_vals [ num ] = cnt <EOL> prim_num [ num ] = cnt <EOL> for num in num_data : <EOL> print ( prim_num [ num ] ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> import math <EOL> class mymath : <EOL> pi = <NUM_LIT> <EOL> def pnum_eratosthenes ( self , n ) : <EOL> ptable = [ <NUM_LIT:0> for i in range ( n + <NUM_LIT:1> ) ] <EOL> plist = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if ptable [ i ] == <NUM_LIT:0> : <EOL> plist . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> ptable [ j ] = <NUM_LIT:1> <EOL> return plist <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> def mul ( self , A , B ) : <EOL> ans = [ ] <EOL> for a in A : <EOL> c = <NUM_LIT:0> <EOL> for j , row in enumerate ( a ) : <EOL> c += row * B [ j ] <EOL> ans . append ( c ) <EOL> return ans <EOL> mymath = mymath ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> def get_input ( ) : <EOL> N = [ ] <EOL> while True : <EOL> try : <EOL> N . append ( int ( input ( ) ) ) <EOL> except EOFError : <EOL> break <EOL> return N <EOL> N = [ int ( x ) for x in input ( ) . split ( ) ] <EOL> N = sorted ( N ) <EOL> S = '<STR_LIT>' <EOL> for i in N [ : : - <NUM_LIT:1> ] : <EOL> S += str ( i ) + '<STR_LIT:U+0020>' <EOL> print ( S [ : - <NUM_LIT:1> ] )
import sys <EOL> from decimal import Decimal <EOL> def main ( ) : <EOL> for input_line in sys . stdin : <EOL> x1 = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:0> ] ) <EOL> y1 = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:1> ] ) <EOL> p = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:2> ] ) <EOL> x2 = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:3> ] ) <EOL> y2 = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:4> ] ) <EOL> q = int ( input_line . split ( '<STR_LIT:U+0020>' ) [ <NUM_LIT:5> ] ) <EOL> multiplicand1 , multiplicand2 = calculate1 ( x1 , x2 ) <EOL> after_y1 , after_y2 , after_p , after_q = calculate2 ( y1 , y2 , p , q , multiplicand1 , multiplicand2 ) <EOL> calculate3 ( after_y1 , after_y2 , after_p , after_q , x1 , y1 , p ) <EOL> def calculate1 ( x1 , x2 ) : <EOL> if ( x1 >= <NUM_LIT:0> and x2 >= <NUM_LIT:0> ) or ( x1 < <NUM_LIT:0> and x2 < <NUM_LIT:0> ) : <EOL> multiplicand1 = - x2 <EOL> multiplicand2 = x1 <EOL> return multiplicand1 , multiplicand2 <EOL> else : <EOL> multiplicand1 = abs ( x2 ) <EOL> multiplicand2 = abs ( x1 ) <EOL> return multiplicand1 , multiplicand2 <EOL> def calculate2 ( y1 , y2 , p , q , multiplicand1 , multiplicand2 ) : <EOL> after_y1 = Decimal ( y1 * multiplicand1 ) <EOL> after_y2 = Decimal ( y2 * multiplicand2 ) <EOL> after_p = Decimal ( p * multiplicand1 ) <EOL> after_q = Decimal ( q * multiplicand2 ) <EOL> return after_y1 , after_y2 , after_p , after_q <EOL> def calculate3 ( after_y1 , after_y2 , after_p , after_q , x1 , y1 , p ) : <EOL> y = Decimal ( after_p + after_q ) / Decimal ( after_y1 + after_y2 ) <EOL> y = round ( y , <NUM_LIT:3> ) <EOL> x = Decimal ( p - y1 * y ) / Decimal ( x1 ) <EOL> x = round ( x , <NUM_LIT:3> ) <EOL> print ( '<STR_LIT>' % ( x , y ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
from math import sqrt <EOL> def circle ( x1 , y1 , x2 , y2 , x3 , y3 ) : <EOL> if x1 == <NUM_LIT:0> : <EOL> dx = <NUM_LIT:1> <EOL> x1 = x1 + dx <EOL> x2 = x2 + dx <EOL> x3 = x3 + dx <EOL> else : <EOL> dx = <NUM_LIT:0> <EOL> if y2 == <NUM_LIT:0> : <EOL> dy = <NUM_LIT:1> <EOL> y1 = y1 + dy <EOL> y2 = y2 + dy <EOL> y3 = y3 + dy <EOL> else : <EOL> dy = <NUM_LIT:0> <EOL> A = [ [ x1 , y1 , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ] , [ x2 , y2 , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ] , [ x3 , y3 , <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] ] <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> A [ <NUM_LIT:0> ] = [ x / A [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] for x in A [ <NUM_LIT:0> ] ] <EOL> A [ <NUM_LIT:1> ] = [ A [ <NUM_LIT:1> ] [ j ] - A [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] * A [ <NUM_LIT:0> ] [ j ] for j in range ( <NUM_LIT:6> ) ] <EOL> A [ <NUM_LIT:2> ] = [ A [ <NUM_LIT:2> ] [ j ] - A [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] * A [ <NUM_LIT:0> ] [ j ] for j in range ( <NUM_LIT:6> ) ] <EOL> for j in range ( <NUM_LIT:3> ) : <EOL> A [ j ] = A [ j ] [ <NUM_LIT:1> : ] + A [ j ] [ : <NUM_LIT:1> ] <EOL> A = A [ <NUM_LIT:1> : ] + A [ : <NUM_LIT:1> ] <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> A [ i ] = A [ i ] [ : <NUM_LIT:3> ] <EOL> V = [ - x1 ** <NUM_LIT:2> - y1 ** <NUM_LIT:2> , - x2 ** <NUM_LIT:2> - y2 ** <NUM_LIT:2> , - x3 ** <NUM_LIT:2> - y3 ** <NUM_LIT:2> ] <EOL> M = [ ( A [ i ] [ <NUM_LIT:0> ] * V [ <NUM_LIT:0> ] + A [ i ] [ <NUM_LIT:1> ] * V [ <NUM_LIT:1> ] + A [ i ] [ <NUM_LIT:2> ] * V [ <NUM_LIT:2> ] ) for i in range ( <NUM_LIT:3> ) ] <EOL> xcenter = - <NUM_LIT:0.5> * M [ <NUM_LIT:0> ] - dx <EOL> ycenter = - <NUM_LIT:0.5> * M [ <NUM_LIT:1> ] - dy <EOL> radius = sqrt ( ( M [ <NUM_LIT:0> ] ** <NUM_LIT:2> ) / <NUM_LIT:4> + ( M [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) / <NUM_LIT:4> - M [ <NUM_LIT:2> ] ) <EOL> return xcenter , ycenter , radius <EOL> n = int ( input ( ) ) <EOL> for line in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <EOL> xc , yc , ra = circle ( x1 , y1 , x2 , y2 , x3 , y3 ) <EOL> print ( '<STR_LIT>' % ( xc , yc , ra ) )
from bisect import bisect_right <EOL> max_number = <NUM_LIT> <EOL> prime_flag_list = [ True ] * max_number <EOL> prime_flag_list [ <NUM_LIT:0> ] = False <EOL> prime_flag_list [ <NUM_LIT:1> ] = False <EOL> prime_flag_list [ <NUM_LIT:4> : : <NUM_LIT:2> ] = [ False ] * len ( prime_flag_list [ <NUM_LIT:4> : : <NUM_LIT:2> ] ) <EOL> for i in range ( <NUM_LIT:3> , int ( max_number ** <NUM_LIT:0.5> ) + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> prime_flag_list [ i * i : : i ] = [ False ] * len ( prime_flag_list [ i * i : : i ] ) <EOL> prime_list = [ i for i in range ( <NUM_LIT:2> , max_number ) if prime_flag_list [ i ] ] <EOL> while True : <EOL> try : <EOL> input = int ( raw_input ( ) ) <EOL> except EOFError : <EOL> break <EOL> print bisect_right ( prime_list , input )
if __name__ == '<STR_LIT:__main__>' : <EOL> while True : <EOL> loop = int ( input ( ) ) <EOL> if loop == <NUM_LIT:0> : <EOL> break <EOL> data = [ int ( input ( ) ) for _ in range ( loop ) ] <EOL> max_total = max ( data ) <EOL> total = <NUM_LIT:0> <EOL> for d in data : <EOL> if d > <NUM_LIT:0> : <EOL> total += d <EOL> if total > max_total : <EOL> max_total = total <EOL> else : <EOL> if total > abs ( d ) : <EOL> total += d <EOL> else : <EOL> total = <NUM_LIT:0> <EOL> print ( max_total )
def get_input ( ) : <EOL> while True : <EOL> try : <EOL> yield "<STR_LIT>" . join ( input ( ) ) <EOL> except EOFError : <EOL> break <EOL> def calcGCD ( a , b ) : <EOL> if a > b : <EOL> large = a <EOL> small = b <EOL> elif a < b : <EOL> large = b <EOL> small = a <EOL> else : <EOL> return a <EOL> while True : <EOL> if large == small : <EOL> return large <EOL> temp_small = large - small <EOL> if temp_small < small : <EOL> large = small <EOL> small = temp_small <EOL> else : <EOL> large = temp_small <EOL> small = small <EOL> def calcLCM ( a , b , gcd ) : <EOL> lcm = a * b / gcd <EOL> return lcm <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> array = list ( get_input ( ) ) <EOL> for i in range ( len ( array ) ) : <EOL> temp_a , temp_b = array [ i ] . split ( ) <EOL> a , b = int ( temp_a ) , int ( temp_b ) <EOL> gcd = calcGCD ( a , b ) <EOL> lcm = calcLCM ( a , b , gcd ) <EOL> lcm = int ( lcm ) <EOL> print ( "<STR_LIT>" . format ( gcd , lcm ) )
import sys <EOL> class P ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . x = x <EOL> self . y = y <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' . format ( self . x , self . y ) <EOL> class Line ( object ) : <EOL> def __init__ ( self , p1 , p2 ) : <EOL> self . p1 = p1 <EOL> self . p2 = p2 <EOL> self . epsilon = <NUM_LIT> <EOL> def is_over ( self , p ) : <EOL> if abs ( self . p2 . x - self . p1 . x ) < self . epsilon : <EOL> return self . p1 . x > p . x <EOL> elif abs ( self . p2 . y - self . p1 . y ) < self . epsilon : <EOL> return self . p1 . y > p . y <EOL> else : <EOL> a = ( self . p2 . y - self . p1 . y ) / ( self . p2 . x - self . p1 . x ) <EOL> b = self . p1 . y <EOL> y = a * ( p . x - self . p1 . x ) + b <EOL> return y > p . y <EOL> def run ( ) : <EOL> for i in sys . stdin : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = list ( map ( float , i . split ( ) ) ) <EOL> p1 , p2 , p3 , p = P ( x1 , y1 ) , P ( x2 , y2 ) , P ( x3 , y3 ) , P ( xp , yp ) <EOL> l_12 = Line ( p1 , p2 ) <EOL> l_23 = Line ( p2 , p3 ) <EOL> l_31 = Line ( p3 , p1 ) <EOL> res = l_12 . is_over ( p3 ) == l_12 . is_over ( p ) <EOL> res &= l_23 . is_over ( p1 ) == l_23 . is_over ( p ) <EOL> res &= l_31 . is_over ( p2 ) == l_31 . is_over ( p ) <EOL> if res : <EOL> print ( '<STR_LIT>' ) <EOL> else : <EOL> print ( '<STR_LIT>' ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> run ( )
import sys <EOL> class Paper : <EOL> def __init__ ( self ) : <EOL> self . paper = [ [ <NUM_LIT:0> for x in range ( <NUM_LIT:10> ) ] for y in range ( <NUM_LIT:10> ) ] <EOL> def white_space ( self ) : <EOL> s = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:10> ) : <EOL> for y in range ( <NUM_LIT:10> ) : <EOL> if self . paper [ x ] [ y ] == <NUM_LIT:0> : <EOL> s += <NUM_LIT:1> <EOL> return s <EOL> def most_dark ( self ) : <EOL> s = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:10> ) : <EOL> for y in range ( <NUM_LIT:10> ) : <EOL> if self . paper [ x ] [ y ] > s : <EOL> s = self . paper [ x ] [ y ] <EOL> return s <EOL> def drop ( self , x , y , size ) : <EOL> r = [ ] <EOL> if size == <NUM_LIT:1> : <EOL> r . append ( ( x , y ) ) <EOL> r . append ( ( x - <NUM_LIT:1> , y ) ) <EOL> r . append ( ( x + <NUM_LIT:1> , y ) ) <EOL> r . append ( ( x , y - <NUM_LIT:1> ) ) <EOL> r . append ( ( x , y + <NUM_LIT:1> ) ) <EOL> elif size == <NUM_LIT:2> : <EOL> r = [ ( i , j ) for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) for j in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) ] <EOL> elif size == <NUM_LIT:3> : <EOL> r = [ ( i , j ) for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) for j in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) ] <EOL> r . append ( ( x - <NUM_LIT:2> , y ) ) <EOL> r . append ( ( x + <NUM_LIT:2> , y ) ) <EOL> r . append ( ( x , y - <NUM_LIT:2> ) ) <EOL> r . append ( ( x , y + <NUM_LIT:2> ) ) <EOL> else : <EOL> pass <EOL> r = filter ( self . out_of_paper , r ) <EOL> try : <EOL> for p in r : <EOL> self . paper [ p [ <NUM_LIT:0> ] ] [ p [ <NUM_LIT:1> ] ] += <NUM_LIT:1> <EOL> except : <EOL> pass <EOL> return self <EOL> def out_of_paper ( self , p ) : <EOL> if <NUM_LIT:0> <= p [ <NUM_LIT:0> ] < <NUM_LIT:10> and <NUM_LIT:0> <= p [ <NUM_LIT:1> ] < <NUM_LIT:10> : <EOL> return True <EOL> else : <EOL> return False <EOL> paper = Paper ( ) <EOL> for line in sys . stdin : <EOL> ( x , y , size ) = tuple ( map ( int , line . split ( '<STR_LIT:U+002C>' ) ) ) <EOL> paper . drop ( x , y , size ) <EOL> print paper . white_space ( ) <EOL> print paper . most_dark ( )
max_number = <NUM_LIT> <EOL> prime_flag_list = [ True ] * max_number <EOL> prime_flag_list [ <NUM_LIT:0> ] = False <EOL> prime_flag_list [ <NUM_LIT:1> ] = False <EOL> prime_flag_list [ <NUM_LIT:4> : : <NUM_LIT:2> ] = [ False ] * len ( prime_flag_list [ <NUM_LIT:4> : : <NUM_LIT:2> ] ) <EOL> for i in range ( <NUM_LIT:3> , int ( max_number ** <NUM_LIT:0.5> ) + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> prime_flag_list [ i * i : : i ] = [ False ] * len ( prime_flag_list [ i * i : : i ] ) <EOL> prime_list = [ i for i in range ( <NUM_LIT:2> , max_number ) if prime_flag_list [ i ] ] <EOL> while True : <EOL> try : <EOL> input = int ( raw_input ( ) ) <EOL> except EOFError : <EOL> break <EOL> for i in range ( <NUM_LIT:0> , len ( prime_list ) ) : <EOL> if prime_list [ i ] > input : <EOL> print i <EOL> break <EOL> if i >= len ( prime_list ) - <NUM_LIT:1> : <EOL> print len ( prime_list )
import sys <EOL> paper = [ [ <NUM_LIT:0> ] * <NUM_LIT:10> for x in xrange ( <NUM_LIT:10> ) ] <EOL> def dropInc ( coord , size ) : <EOL> x , y = coord <EOL> if size == <NUM_LIT:1> : <EOL> paper [ y ] [ x ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:0> : <EOL> paper [ y - <NUM_LIT:1> ] [ x ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:9> : <EOL> paper [ y + <NUM_LIT:1> ] [ x ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> : <EOL> paper [ y ] [ x - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:9> : <EOL> paper [ y ] [ x + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> elif size == <NUM_LIT:2> : <EOL> dropInc ( coord , <NUM_LIT:1> ) <EOL> if y > <NUM_LIT:0> and x > <NUM_LIT:0> : <EOL> paper [ y - <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:9> and y > <NUM_LIT:0> : <EOL> paper [ y - <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x > <NUM_LIT:0> and y < <NUM_LIT:9> : <EOL> paper [ y + <NUM_LIT:1> ] [ x - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:9> and y < <NUM_LIT:9> : <EOL> paper [ y + <NUM_LIT:1> ] [ x + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> elif size == <NUM_LIT:3> : <EOL> dropInc ( coord , <NUM_LIT:2> ) <EOL> if x > <NUM_LIT:1> : <EOL> paper [ y ] [ x - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if x < <NUM_LIT:8> : <EOL> paper [ y ] [ x + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> if y > <NUM_LIT:1> : <EOL> paper [ y - <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> if y < <NUM_LIT:8> : <EOL> paper [ y + <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> for line in sys . stdin . readlines ( ) : <EOL> line = line . strip ( ) <EOL> x , y , size = map ( int , line . split ( "<STR_LIT:U+002C>" ) ) <EOL> dropInc ( ( x , y ) , size ) <EOL> print sum ( [ <NUM_LIT:1> if x == <NUM_LIT:0> else <NUM_LIT:0> for y in paper for x in y ] ) <EOL> print max ( [ x for y in paper for x in y ] )
import heapq <EOL> from collections import deque <EOL> from enum import Enum <EOL> import sys <EOL> import math <EOL> from _heapq import heappush , heappop <EOL> import copy <EOL> BIG_NUM = <NUM_LIT> <EOL> HUGE_NUM = <NUM_LIT> <EOL> MOD = <NUM_LIT> <EOL> EPS = <NUM_LIT> <EOL> sys . setrecursionlimit ( <NUM_LIT> ) <EOL> num_query = int ( input ( ) ) <EOL> for _ in range ( num_query ) : <EOL> A = list ( map ( int , input ( ) ) ) <EOL> B = list ( map ( int , input ( ) ) ) <EOL> if len ( A ) > <NUM_LIT> or len ( B ) > <NUM_LIT> : <EOL> print ( "<STR_LIT>" ) <EOL> continue <EOL> if len ( B ) > len ( A ) : <EOL> A , B = B , A <EOL> A . reverse ( ) <EOL> B . reverse ( ) <EOL> ANS = deque ( ) <EOL> add = <NUM_LIT:0> <EOL> for digit in range ( len ( A ) ) : <EOL> if digit >= len ( B ) : <EOL> tmp = add + A [ digit ] <EOL> add = tmp // <NUM_LIT:10> <EOL> ANS . append ( tmp % <NUM_LIT:10> ) <EOL> else : <EOL> tmp = add + B [ digit ] + A [ digit ] <EOL> add = tmp // <NUM_LIT:10> <EOL> ANS . append ( tmp % <NUM_LIT:10> ) <EOL> if len ( A ) == <NUM_LIT> and add == <NUM_LIT:1> : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> if add == <NUM_LIT:1> : <EOL> ANS . append ( <NUM_LIT:1> ) <EOL> while len ( ANS ) > <NUM_LIT:0> : <EOL> print ( "<STR_LIT>" % ( ANS . pop ( ) ) , end = "<STR_LIT>" ) <EOL> print ( )
import math <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> n = int ( input ( ) ) <EOL> for i in range ( n ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <EOL> points_list = [ [ x1 , y1 ] , [ x2 , y2 ] , [ x3 , y3 ] ] <EOL> points_list . sort ( ) <EOL> if points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] == points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] : <EOL> py = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> if points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] == points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] : <EOL> px = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> else : <EOL> a2_s = ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a2 = - <NUM_LIT:1> / a2_s <EOL> m13x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m13y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> b2 = m13y - a2 * m13x <EOL> px = ( py - b2 ) / a2 <EOL> elif points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] == points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] : <EOL> py = ( points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> if points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] == points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] : <EOL> px = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> else : <EOL> a2_s = ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a2 = - <NUM_LIT:1> / a2_s <EOL> m13x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m13y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> b2 = m13y - a2 * m13x <EOL> px = ( py - b2 ) / a2 <EOL> elif points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] : <EOL> px = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> a2_s = ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a2 = - <NUM_LIT:1> / a2_s <EOL> m13x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m13y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> b2 = m13y - a2 * m13x <EOL> py = a2 * px + b2 <EOL> elif points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] == points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] : <EOL> px = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> a1_s = ( points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a1 = - <NUM_LIT:1> / a1_s <EOL> m12x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m12y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> b1 = m12y - a1 * m12x <EOL> py = a1 * px + b1 <EOL> else : <EOL> a1_s = ( points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a1 = - <NUM_LIT:1> / a1_s <EOL> a2_s = ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) / ( points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) <EOL> a2 = - <NUM_LIT:1> / a2_s <EOL> m12x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m12y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> m13x = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] ) / <NUM_LIT:2> <EOL> m13y = ( points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] + points_list [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ) / <NUM_LIT:2> <EOL> b1 = m12y - a1 * m12x <EOL> b2 = m13y - a2 * m13x <EOL> px = ( b2 - b1 ) / ( a1 - a2 ) <EOL> py = a1 * px + b1 <EOL> r = math . sqrt ( math . pow ( ( px - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] ) , <NUM_LIT:2> ) + math . pow ( ( py - points_list [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ) , <NUM_LIT:2> ) ) <EOL> print ( '<STR_LIT>' . format ( px , py , r ) )
if __name__ == "<STR_LIT:__main__>" : <EOL> num = int ( input ( ) ) <EOL> inputline = [ "<STR_LIT>" ] * num <EOL> for i in range ( <NUM_LIT:0> , num ) : <EOL> inputline [ i ] = input ( ) <EOL> for line in inputline : <EOL> a = int ( line . split ( "<STR_LIT:U+0020>" ) [ <NUM_LIT:0> ] ) <EOL> b = int ( line . split ( "<STR_LIT:U+0020>" ) [ <NUM_LIT:1> ] ) <EOL> c = int ( line . split ( "<STR_LIT:U+0020>" ) [ <NUM_LIT:2> ] ) <EOL> if ( a * a + b * b == c * c or b * b + c * c == a * a or c * c + a * a == b * b ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" )
p = [ [ <NUM_LIT:0> for j in range ( <NUM_LIT:10> ) ] for i in range ( <NUM_LIT:10> ) ] <EOL> s1i = [ - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] <EOL> s1j = [ <NUM_LIT:0> , - <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:0> ] <EOL> s2i = [ - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> ] <EOL> s2j = [ - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , - <NUM_LIT:1> , <NUM_LIT:1> , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> ] <EOL> s3i = [ - <NUM_LIT:2> , - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> ] <EOL> s3j = [ <NUM_LIT:0> , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , - <NUM_LIT:2> , - <NUM_LIT:1> , <NUM_LIT:1> , <NUM_LIT:2> , - <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ] <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> except : <EOL> break <EOL> p [ y ] [ x ] += <NUM_LIT:1> <EOL> if s == <NUM_LIT:1> : <EOL> for k in range ( len ( s1i ) ) : <EOL> xx = x + s1j [ k ] <EOL> yy = y + s1i [ k ] <EOL> if <NUM_LIT:0> <= xx and xx < <NUM_LIT:10> and <NUM_LIT:0> <= yy and yy < <NUM_LIT:10> : <EOL> p [ yy ] [ xx ] += <NUM_LIT:1> <EOL> elif s == <NUM_LIT:2> : <EOL> for k in range ( len ( s2i ) ) : <EOL> xx = x + s2j [ k ] <EOL> yy = y + s2i [ k ] <EOL> if <NUM_LIT:0> <= xx and xx < <NUM_LIT:10> and <NUM_LIT:0> <= yy and yy < <NUM_LIT:10> : <EOL> p [ yy ] [ xx ] += <NUM_LIT:1> <EOL> else : <EOL> for k in range ( len ( s3i ) ) : <EOL> xx = x + s3j [ k ] <EOL> yy = y + s3i [ k ] <EOL> if <NUM_LIT:0> <= xx and xx < <NUM_LIT:10> and <NUM_LIT:0> <= yy and yy < <NUM_LIT:10> : <EOL> p [ yy ] [ xx ] += <NUM_LIT:1> <EOL> cnt = <NUM_LIT:0> <EOL> m = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if p [ i ] [ j ] == <NUM_LIT:0> : <EOL> cnt += <NUM_LIT:1> <EOL> else : <EOL> pass <EOL> m = max ( p [ i ] [ j ] , m ) <EOL> print ( cnt ) <EOL> print ( m )
sheet = [ [ <NUM_LIT:0> for _ in range ( <NUM_LIT:10> ) ] for _ in range ( <NUM_LIT:10> ) ] <EOL> small_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) ) <EOL> middle_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) ) <EOL> large_range = ( ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:2> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:2> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:2> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:2> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) ) <EOL> def drop ( x , y , drop_range ) : <EOL> for dx , dy in drop_range : <EOL> newx , newy = x + dx , y + dy <EOL> if <NUM_LIT:0> <= newx <= <NUM_LIT:9> and <NUM_LIT:0> <= newy <= <NUM_LIT:9> : <EOL> sheet [ newx ] [ newy ] += <NUM_LIT:1> <EOL> while True : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( "<STR_LIT:U+002C>" ) ) <EOL> if s == <NUM_LIT:1> : <EOL> drop ( x , y , small_range ) <EOL> elif s == <NUM_LIT:2> : <EOL> drop ( x , y , middle_range ) <EOL> else : <EOL> drop ( x , y , large_range ) <EOL> except EOFError : <EOL> break <EOL> zero_cnt = <NUM_LIT:0> <EOL> max_ink = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:10> ) : <EOL> for y in range ( <NUM_LIT:10> ) : <EOL> ink = sheet [ x ] [ y ] <EOL> if ink == <NUM_LIT:0> : <EOL> zero_cnt += <NUM_LIT:1> <EOL> if max_ink < ink : <EOL> max_ink = ink <EOL> print ( zero_cnt ) <EOL> print ( max_ink )
import sys <EOL> count = int ( raw_input ( ) ) <EOL> while <NUM_LIT:0> < count : <EOL> count -= <NUM_LIT:1> <EOL> a = map ( int , raw_input ( ) . split ( ) ) <EOL> if a [ <NUM_LIT:1> ] < a [ <NUM_LIT:2> ] : <EOL> tmp = a [ <NUM_LIT:1> ] <EOL> a [ <NUM_LIT:1> ] = a [ <NUM_LIT:2> ] <EOL> a [ <NUM_LIT:2> ] = tmp <EOL> if a [ <NUM_LIT:0> ] < a [ <NUM_LIT:1> ] : <EOL> tmp = a [ <NUM_LIT:0> ] <EOL> a [ <NUM_LIT:0> ] = a [ <NUM_LIT:1> ] <EOL> a [ <NUM_LIT:1> ] = tmp <EOL> n = a [ <NUM_LIT:1> ] * a [ <NUM_LIT:1> ] + a [ <NUM_LIT:2> ] * a [ <NUM_LIT:2> ] <EOL> if a [ <NUM_LIT:0> ] * a [ <NUM_LIT:0> ] == n : <EOL> print "<STR_LIT>" <EOL> else : <EOL> print "<STR_LIT>"
import sys <EOL> def prod2d ( vec1 , vec2 ) : <EOL> return vec1 [ <NUM_LIT:0> ] * vec2 [ <NUM_LIT:1> ] - vec1 [ <NUM_LIT:1> ] * vec2 [ <NUM_LIT:0> ] <EOL> lineNumber = <NUM_LIT:0> <EOL> for line in sys . stdin . readlines ( ) : <EOL> lineNumber += <NUM_LIT:1> <EOL> List = map ( float , line . strip ( ) . split ( ) ) <EOL> nodes = [ [ List [ <NUM_LIT:0> ] , List [ <NUM_LIT:1> ] ] , [ List [ <NUM_LIT:2> ] , List [ <NUM_LIT:3> ] ] , [ List [ <NUM_LIT:4> ] , List [ <NUM_LIT:5> ] ] ] <EOL> point = [ List [ <NUM_LIT:6> ] , List [ <NUM_LIT:7> ] ] <EOL> ABvec = [ nodes [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , nodes [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ] <EOL> BCvec = [ nodes [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , nodes [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ] <EOL> CAvec = [ nodes [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , nodes [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ] <EOL> APvec = [ point [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:0> ] [ <NUM_LIT:0> ] , point [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:0> ] [ <NUM_LIT:1> ] ] <EOL> BPvec = [ point [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:1> ] [ <NUM_LIT:0> ] , point [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:1> ] [ <NUM_LIT:1> ] ] <EOL> CPvec = [ point [ <NUM_LIT:0> ] - nodes [ <NUM_LIT:2> ] [ <NUM_LIT:0> ] , point [ <NUM_LIT:1> ] - nodes [ <NUM_LIT:2> ] [ <NUM_LIT:1> ] ] <EOL> a = prod2d ( CAvec , APvec ) <EOL> b = prod2d ( ABvec , BPvec ) <EOL> c = prod2d ( BCvec , CPvec ) <EOL> if a > <NUM_LIT:0> and b > <NUM_LIT:0> and c > <NUM_LIT:0> : print "<STR_LIT>" <EOL> elif a < <NUM_LIT:0> and b < <NUM_LIT:0> and c < <NUM_LIT:0> : print "<STR_LIT>" <EOL> else : print "<STR_LIT>"
import sys <EOL> def gcd ( a , b ) : <EOL> return gcd ( b , a % b ) if a % b else b <EOL> def lcm ( a , b ) : <EOL> return a * b / gcd ( a , b ) <EOL> for line in sys . stdin : <EOL> data = map ( int , line . split ( ) ) <EOL> a , b , c , d , e , f = data <EOL> if a == <NUM_LIT:0> : <EOL> y = c * <NUM_LIT:1.0> / b <EOL> x = ( f - e * y ) * <NUM_LIT:1.0> / d <EOL> print "<STR_LIT>" % ( round ( x , <NUM_LIT:4> ) , round ( y , <NUM_LIT:4> ) ) <EOL> continue <EOL> if b == <NUM_LIT:0> : <EOL> x = c * <NUM_LIT:1.0> / a <EOL> y = ( f - d * x ) * <NUM_LIT:1.0> / e <EOL> print "<STR_LIT>" % ( round ( x , <NUM_LIT:4> ) , round ( y , <NUM_LIT:4> ) ) <EOL> continue <EOL> if d == <NUM_LIT:0> : <EOL> y = f * <NUM_LIT:1.0> / e <EOL> x = ( c - b * y ) * <NUM_LIT:1.0> / a <EOL> print "<STR_LIT>" % ( round ( x , <NUM_LIT:4> ) , round ( y , <NUM_LIT:4> ) ) <EOL> continue <EOL> if e == <NUM_LIT:0> : <EOL> x = f * <NUM_LIT:1.0> / d <EOL> y = ( c - a * x ) * <NUM_LIT:1.0> / b <EOL> print "<STR_LIT>" % ( round ( x , <NUM_LIT:4> ) , round ( y , <NUM_LIT:4> ) ) <EOL> continue <EOL> ix = lcm ( a , d ) / a <EOL> jx = lcm ( a , d ) / d <EOL> iy = lcm ( b , e ) / b <EOL> jy = lcm ( b , e ) / e <EOL> x = ( c * <NUM_LIT:1.0> * iy - f * jy ) / ( a * iy - d * jy ) <EOL> y = ( c * <NUM_LIT:1.0> * ix - f * jx ) / ( b * ix - e * jx ) <EOL> print "<STR_LIT>" % ( round ( x , <NUM_LIT:4> ) , round ( y , <NUM_LIT:4> ) )
def solve ( a , b , c , d , e , f ) : <EOL> agn = a * e - b * d <EOL> x = ( e * c - b * f ) / float ( agn ) <EOL> y = ( - d * c + a * f ) / float ( agn ) <EOL> if x == <NUM_LIT:0.> : x = <NUM_LIT:0.> <EOL> if y == <NUM_LIT:0.> : y = <NUM_LIT:0.> <EOL> return ( x , y ) <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> n = input ( ) <EOL> for i in xrange ( n ) : <EOL> x = [ <NUM_LIT:0> for i in xrange ( <NUM_LIT:3> ) ] <EOL> y = [ <NUM_LIT:0> for i in xrange ( <NUM_LIT:3> ) ] <EOL> a , b , t = [ [ <NUM_LIT:0> for i in xrange ( <NUM_LIT:2> ) ] for i in xrange ( <NUM_LIT:3> ) ] <EOL> p , q , s = [ [ <NUM_LIT:0> for i in xrange ( <NUM_LIT:2> ) ] for i in xrange ( <NUM_LIT:3> ) ] <EOL> x [ <NUM_LIT:0> ] , y [ <NUM_LIT:0> ] , x [ <NUM_LIT:1> ] , y [ <NUM_LIT:1> ] , x [ <NUM_LIT:2> ] , y [ <NUM_LIT:2> ] = map ( float , raw_input ( ) . split ( ) ) <EOL> for j in xrange ( <NUM_LIT:2> ) : <EOL> a [ j ] = ( x [ j + <NUM_LIT:1> ] + x [ j ] ) / <NUM_LIT:2> <EOL> b [ j ] = ( y [ j + <NUM_LIT:1> ] + y [ j ] ) / <NUM_LIT:2> <EOL> if x [ j + <NUM_LIT:1> ] - x [ j ] == <NUM_LIT:0.> : <EOL> p [ j ] = <NUM_LIT:0.> <EOL> q [ j ] = - <NUM_LIT:1.> <EOL> s [ j ] = - b [ j ] <EOL> elif y [ j + <NUM_LIT:1> ] - y [ j ] == <NUM_LIT:0.> : <EOL> p [ j ] = - <NUM_LIT:1.> <EOL> q [ j ] = <NUM_LIT:0.> <EOL> s [ j ] = - a [ j ] <EOL> else : <EOL> t [ j ] = ( y [ j + <NUM_LIT:1> ] - y [ j ] ) / ( x [ j + <NUM_LIT:1> ] - x [ j ] ) <EOL> p [ j ] = - <NUM_LIT:1.> / t [ j ] <EOL> q [ j ] = - <NUM_LIT:1.> <EOL> s [ j ] = - ( a [ j ] / t [ j ] ) - b [ j ] <EOL> c = solve ( p [ <NUM_LIT:0> ] , q [ <NUM_LIT:0> ] , s [ <NUM_LIT:0> ] , p [ <NUM_LIT:1> ] , q [ <NUM_LIT:1> ] , s [ <NUM_LIT:1> ] ) <EOL> r = ( ( x [ <NUM_LIT:0> ] - c [ <NUM_LIT:0> ] ) ** <NUM_LIT:2> + ( y [ <NUM_LIT:0> ] - c [ <NUM_LIT:1> ] ) ** <NUM_LIT:2> ) ** <NUM_LIT:0.5> <EOL> print "<STR_LIT>" % ( c [ <NUM_LIT:0> ] , c [ <NUM_LIT:1> ] , r ) <EOL> except EOFError : <EOL> break
"""<STR_LIT>""" <EOL> import math <EOL> import sys <EOL> def segment_sieve ( begin , end ) : <EOL> """<STR_LIT>""" <EOL> assert <NUM_LIT:1> < begin <= end <EOL> sqrt_end = math . ceil ( math . sqrt ( end ) ) <EOL> is_prime_small = [ True for i in range ( sqrt_end ) ] <EOL> is_prime_small [ <NUM_LIT:0> ] = False <EOL> is_prime_small [ <NUM_LIT:1> ] = False <EOL> is_prime = [ True for i in range ( end - begin ) ] <EOL> for i in range ( <NUM_LIT:2> , sqrt_end ) : <EOL> if is_prime_small [ i ] : <EOL> for j in range ( <NUM_LIT:2> * i , sqrt_end , i ) : <EOL> is_prime_small [ j ] = False <EOL> for k in range ( max ( <NUM_LIT:2> , ( begin + i - <NUM_LIT:1> ) // i ) * i , end , i ) : <EOL> is_prime [ k - begin ] = False <EOL> primes = [ i for i , cond in enumerate ( is_prime , begin ) if cond ] <EOL> return is_prime , primes <EOL> def main ( ) : <EOL> ns = [ int ( n ) for n in sys . stdin . readlines ( ) ] <EOL> max_n = max ( ns ) <EOL> begin = <NUM_LIT:2> <EOL> is_prime , _ = segment_sieve ( begin , max_n + <NUM_LIT:1> ) <EOL> for n in ns : <EOL> print ( sum ( is_prime [ : n + <NUM_LIT:1> - begin ] ) ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import math <EOL> def my_round ( x , d = <NUM_LIT:0> ) : <EOL> p = <NUM_LIT:10> ** d <EOL> return float ( math . floor ( ( x * p ) + math . copysign ( <NUM_LIT:0.5> , x ) ) ) / p <EOL> class Equation ( ) : <EOL> def __init__ ( self , a , b , c , d , e , f ) : <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> self . d = d <EOL> self . e = e <EOL> self . f = f <EOL> def calc ( self ) : <EOL> temp = ( self . a * self . e - self . b * self . d ) <EOL> temp_a = ( self . c * self . e - self . b * self . f ) <EOL> temp_b = ( self . a * self . f - self . c * self . d ) <EOL> try : <EOL> x = round ( temp_a / temp + <NUM_LIT:0.> , <NUM_LIT:3> ) <EOL> except ZeroDivisionError : <EOL> x = round ( temp_a / <NUM_LIT:1.0> , <NUM_LIT:4> ) <EOL> try : <EOL> y = round ( temp_b / temp + <NUM_LIT:0.> , <NUM_LIT:3> ) <EOL> except : <EOL> y = round ( temp_b / <NUM_LIT:1.0> , <NUM_LIT:4> ) <EOL> return x , y <EOL> def print ( self ) : <EOL> ans = self . calc ( ) <EOL> print ( "<STR_LIT>" . format ( ans [ <NUM_LIT:0> ] , ans [ <NUM_LIT:1> ] ) ) <EOL> def main ( ) : <EOL> data = [ ] <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> n = input ( ) . split ( ) <EOL> a = float ( n [ <NUM_LIT:0> ] ) <EOL> b = float ( n [ <NUM_LIT:1> ] ) <EOL> c = float ( n [ <NUM_LIT:2> ] ) <EOL> d = float ( n [ <NUM_LIT:3> ] ) <EOL> e = float ( n [ <NUM_LIT:4> ] ) <EOL> f = float ( n [ <NUM_LIT:5> ] ) <EOL> data . append ( Equation ( a , b , c , d , e , f ) ) <EOL> except EOFError : <EOL> break <EOL> for num in data : <EOL> num . print ( ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( )
import sys <EOL> import math <EOL> def solve ( x1 , y1 , x2 , y2 , x3 , y3 ) : <EOL> z1 = - <NUM_LIT:1> * ( x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> ) <EOL> z2 = - <NUM_LIT:1> * ( x2 ** <NUM_LIT:2> + y2 ** <NUM_LIT:2> ) <EOL> z3 = - <NUM_LIT:1> * ( x3 ** <NUM_LIT:2> + y3 ** <NUM_LIT:2> ) <EOL> a11 , a12 , a13 = x1 , y1 , <NUM_LIT:1> <EOL> a21 , a22 , a23 = x2 , y2 , <NUM_LIT:1> <EOL> a31 , a32 , a33 = x3 , y3 , <NUM_LIT:1> <EOL> det = a11 * a22 * a33 + a21 * a32 * a13 + a31 * a12 * a23 - a11 * a32 * a23 - a31 * a22 * a13 - a21 * a12 * a33 <EOL> l = ( ( a22 * a33 - a23 * a32 ) * z1 + ( a13 * a32 - a12 * a33 ) * z2 + ( a12 * a23 - a13 * a22 ) * z3 ) / det <EOL> m = ( ( a23 * a31 - a21 * a33 ) * z1 + ( a11 * a33 - a13 * a31 ) * z2 + ( a13 * a21 - a11 * a23 ) * z3 ) / det <EOL> n = ( ( a21 * a32 - a22 * a31 ) * z1 + ( a12 * a31 - a11 * a32 ) * z2 + ( a11 * a22 - a12 * a21 ) * z3 ) / det <EOL> x , y , r = round ( - l / <NUM_LIT:2> , <NUM_LIT:3> ) , round ( - m / <NUM_LIT:2> , <NUM_LIT:3> ) , round ( math . sqrt ( ( l ** <NUM_LIT:2> ) / <NUM_LIT:4> + ( m ** <NUM_LIT:2> ) / <NUM_LIT:4> - n ) , <NUM_LIT:3> ) <EOL> sol = [ x , y , r ] <EOL> return sol <EOL> n , count = int ( input ( ) ) , <NUM_LIT:0> <EOL> array = [ ] <EOL> for i in sys . stdin : <EOL> array . append ( i ) <EOL> count += <NUM_LIT:1> <EOL> if count == n : <EOL> break <EOL> for i in range ( len ( array ) ) : <EOL> x = array [ i ] <EOL> p = x . split ( ) <EOL> res = solve ( float ( p [ <NUM_LIT:0> ] ) , float ( p [ <NUM_LIT:1> ] ) , float ( p [ <NUM_LIT:2> ] ) , float ( p [ <NUM_LIT:3> ] ) , float ( p [ <NUM_LIT:4> ] ) , float ( p [ <NUM_LIT:5> ] ) ) <EOL> print ( '<STR_LIT>' . format ( res [ <NUM_LIT:0> ] , res [ <NUM_LIT:1> ] , res [ <NUM_LIT:2> ] ) )
import sys <EOL> class math : <EOL> pi = <NUM_LIT> <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> math = math ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> for line in sys . stdin . readlines ( ) : <EOL> x , y = [ int ( temp ) for temp in line . split ( ) ] <EOL> print ( "<STR_LIT>" . format ( math . gcd ( x , y ) , math . lcm ( x , y ) ) )
import sys <EOL> from itertools import accumulate <EOL> def input ( ) : return sys . stdin . readline ( ) . strip ( ) <EOL> def list2d ( a , b , c ) : return [ [ c ] * b for i in range ( a ) ] <EOL> def list3d ( a , b , c , d ) : return [ [ [ d ] * c for j in range ( b ) ] for i in range ( a ) ] <EOL> def list4d ( a , b , c , d , e ) : return [ [ [ [ e ] * d for j in range ( c ) ] for j in range ( b ) ] for i in range ( a ) ] <EOL> def ceil ( x , y = <NUM_LIT:1> ) : return int ( - ( - x // y ) ) <EOL> def INT ( ) : return int ( input ( ) ) <EOL> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <EOL> def LIST ( N = None ) : return list ( MAP ( ) ) if N is None else [ INT ( ) for i in range ( N ) ] <EOL> def Yes ( ) : print ( '<STR_LIT>' ) <EOL> def No ( ) : print ( '<STR_LIT>' ) <EOL> def YES ( ) : print ( '<STR_LIT>' ) <EOL> def NO ( ) : print ( '<STR_LIT>' ) <EOL> sys . setrecursionlimit ( <NUM_LIT:10> ** <NUM_LIT:9> ) <EOL> INF = float ( '<STR_LIT>' ) <EOL> MOD = <NUM_LIT:10> ** <NUM_LIT:9> + <NUM_LIT:7> <EOL> def eratosthenes_sieve ( n ) : <EOL> """<STR_LIT>""" <EOL> table = [ <NUM_LIT:0> ] * ( n + <NUM_LIT:1> ) <EOL> prime_list = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if table [ i ] == <NUM_LIT:0> : <EOL> prime_list . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> table [ j ] = <NUM_LIT:1> <EOL> return prime_list <EOL> N = <NUM_LIT> <EOL> primes = eratosthenes_sieve ( N ) <EOL> A = [ <NUM_LIT:0> ] * <NUM_LIT> <EOL> for p in primes : <EOL> A [ p ] = <NUM_LIT:1> <EOL> acc = list ( accumulate ( A ) ) <EOL> while True : <EOL> try : <EOL> a = INT ( ) <EOL> print ( acc [ a ] ) <EOL> except : <EOL> break
import sys <EOL> b = [ list ( <NUM_LIT:0> for i in range ( <NUM_LIT> ) ) for j in range ( <NUM_LIT> ) ] <EOL> def s ( b , x , y ) : <EOL> b [ x ] [ y ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def m ( b , x , y ) : <EOL> b [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x ] [ y ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> def l ( b , x , y ) : <EOL> b [ x ] [ y - <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y - <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x ] [ y ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:2> ] [ y ] += <NUM_LIT:1> <EOL> b [ x - <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x + <NUM_LIT:1> ] [ y + <NUM_LIT:1> ] += <NUM_LIT:1> <EOL> b [ x ] [ y + <NUM_LIT:2> ] += <NUM_LIT:1> <EOL> for line in sys . stdin : <EOL> d = list ( map ( int , line . split ( "<STR_LIT:U+002C>" ) ) ) <EOL> c = d [ <NUM_LIT:2> ] <EOL> x = d [ <NUM_LIT:0> ] + <NUM_LIT:2> <EOL> y = d [ <NUM_LIT:1> ] + <NUM_LIT:2> <EOL> if c == <NUM_LIT:1> : <EOL> s ( b , x , y ) <EOL> elif c == <NUM_LIT:2> : <EOL> m ( b , x , y ) <EOL> elif c == <NUM_LIT:3> : <EOL> l ( b , x , y ) <EOL> ttl = <NUM_LIT:0> <EOL> num = <NUM_LIT:0> <EOL> max = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> for y in range ( <NUM_LIT:2> , <NUM_LIT:12> ) : <EOL> ttl += <NUM_LIT:1> <EOL> if b [ x ] [ y ] == <NUM_LIT:0> : <EOL> num += <NUM_LIT:1> <EOL> if b [ x ] [ y ] > max : <EOL> max = b [ x ] [ y ] <EOL> print ( num ) <EOL> print ( max )
def main ( ) : <EOL> if size == <NUM_LIT:1> : <EOL> index_lis = [ ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) ] <EOL> elif size == <NUM_LIT:2> : <EOL> index_lis = [ ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , ( <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) ] <EOL> elif size == <NUM_LIT:3> : <EOL> index_lis = [ ( <NUM_LIT:0> , <NUM_LIT:0> ) , ( <NUM_LIT:0> , - <NUM_LIT:1> ) , ( <NUM_LIT:0> , - <NUM_LIT:2> ) , ( <NUM_LIT:0> , <NUM_LIT:1> ) , ( <NUM_LIT:0> , <NUM_LIT:2> ) , ( - <NUM_LIT:1> , - <NUM_LIT:1> ) , ( - <NUM_LIT:1> , <NUM_LIT:0> ) , ( - <NUM_LIT:1> , <NUM_LIT:1> ) , <EOL> ( <NUM_LIT:1> , - <NUM_LIT:1> ) , ( <NUM_LIT:1> , <NUM_LIT:0> ) , ( <NUM_LIT:1> , <NUM_LIT:1> ) , ( - <NUM_LIT:2> , <NUM_LIT:0> ) , ( <NUM_LIT:2> , <NUM_LIT:0> ) ] <EOL> drop ( index_lis , x , y ) <EOL> def drop ( index_lis , x , y ) : <EOL> for add_x , add_y in index_lis : <EOL> _x = x + add_x <EOL> _y = y + add_y <EOL> if <NUM_LIT:0> <= _x <= <NUM_LIT:9> and <NUM_LIT:0> <= _y <= <NUM_LIT:9> : <EOL> sheet [ _x ] [ _y ] = sheet [ _x ] [ _y ] + <NUM_LIT:1> <EOL> def check ( ) : <EOL> total = <NUM_LIT:0> <EOL> max_num = <NUM_LIT:0> <EOL> for x in range ( <NUM_LIT:10> ) : <EOL> for y in range ( <NUM_LIT:10> ) : <EOL> if sheet [ x ] [ y ] == <NUM_LIT:0> : <EOL> total += <NUM_LIT:1> <EOL> else : <EOL> if sheet [ x ] [ y ] > max_num : <EOL> max_num = sheet [ x ] [ y ] <EOL> print total <EOL> print max_num <EOL> sheet = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> lis = [ ] <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> lis . append ( <NUM_LIT:0> ) <EOL> sheet . append ( lis ) <EOL> while True : <EOL> try : <EOL> x , y , size = map ( int , raw_input ( ) . split ( '<STR_LIT:U+002C>' ) ) <EOL> main ( ) <EOL> except EOFError : <EOL> check ( ) <EOL> break
l = [ [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ] <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> s = raw_input ( ) <EOL> for w in l : <EOL> for i in xrange ( <NUM_LIT> ) : <EOL> o = w [ i ] <EOL> if s . find ( w [ i ] ) != - <NUM_LIT:1> : <EOL> r = '<STR_LIT>' <EOL> for c in s : <EOL> if c == '<STR_LIT:U+0020>' or c == '<STR_LIT:.>' : r += c <EOL> else : r += chr ( ( ord ( c ) - ord ( '<STR_LIT:a>' ) - i ) % <NUM_LIT> + ord ( '<STR_LIT:a>' ) ) <EOL> print r <EOL> break <EOL> else : <EOL> continue <EOL> break <EOL> except : <EOL> break
class vertex ( object ) : <EOL> def __init__ ( self , a ) : <EOL> self . x = a [ <NUM_LIT:0> ] <EOL> self . y = a [ <NUM_LIT:1> ] <EOL> class circle ( object ) : <EOL> def __init__ ( self , p , r ) : <EOL> self . px = p . x <EOL> self . py = p . y <EOL> self . r = r <EOL> class triangle ( object ) : <EOL> def __init__ ( self , a , b , c ) : <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> import math <EOL> self . ab = math . sqrt ( ( self . a . x - self . b . x ) ** <NUM_LIT:2> + ( self . a . y - self . b . y ) ** <NUM_LIT:2> ) <EOL> self . bc = math . sqrt ( ( self . b . x - self . c . x ) ** <NUM_LIT:2> + ( self . b . y - self . c . y ) ** <NUM_LIT:2> ) <EOL> self . ca = math . sqrt ( ( self . c . x - self . a . x ) ** <NUM_LIT:2> + ( self . c . y - self . a . y ) ** <NUM_LIT:2> ) <EOL> c = self . ab <EOL> a = self . bc <EOL> b = self . ca <EOL> self . cosA = ( b ** <NUM_LIT:2> + c ** <NUM_LIT:2> - a ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * c ) <EOL> self . cosB = ( a ** <NUM_LIT:2> + c ** <NUM_LIT:2> - b ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * a * c ) <EOL> self . cosC = ( b ** <NUM_LIT:2> + a ** <NUM_LIT:2> - c ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * a ) <EOL> self . sinA = math . sqrt ( <NUM_LIT:1> - self . cosA ** <NUM_LIT:2> ) <EOL> self . sinB = math . sqrt ( <NUM_LIT:1> - self . cosB ** <NUM_LIT:2> ) <EOL> self . sinC = math . sqrt ( <NUM_LIT:1> - self . cosC ** <NUM_LIT:2> ) <EOL> self . sin2A = <NUM_LIT:2> * self . sinA * self . cosA <EOL> self . sin2B = <NUM_LIT:2> * self . sinB * self . cosB <EOL> self . sin2C = <NUM_LIT:2> * self . sinC * self . cosC <EOL> def area ( self ) : <EOL> import math <EOL> s = ( self . ab + self . bc + self . ca ) / <NUM_LIT:2> <EOL> S = math . sqrt ( s * ( s - self . ab ) * ( s - self . bc ) * ( s - self . ca ) ) <EOL> return S <EOL> def circumscribed ( self ) : <EOL> R = self . ab / ( <NUM_LIT:2> * self . sinC ) <EOL> px = ( self . sin2A * self . a . x + self . sin2B * self . b . x + self . sin2C * self . c . x ) / ( self . sin2A + self . sin2B + self . sin2C ) <EOL> py = ( self . sin2A * self . a . y + self . sin2B * self . b . y + self . sin2C * self . c . y ) / ( self . sin2A + self . sin2B + self . sin2C ) <EOL> px = round ( px , <NUM_LIT:3> ) <EOL> py = round ( py , <NUM_LIT:3> ) <EOL> R = round ( R , <NUM_LIT:3> ) <EOL> p = vertex ( ( px , py ) ) <EOL> return circle ( p , R ) <EOL> n = eval ( input ( ) ) <EOL> p1 = [ ] <EOL> p2 = [ ] <EOL> p3 = [ ] <EOL> for i in range ( n ) : <EOL> a , b , c , d , e , f = list ( map ( float , input ( ) . split ( ) ) ) <EOL> p1 . append ( vertex ( ( a , b ) ) ) <EOL> p2 . append ( vertex ( ( c , d ) ) ) <EOL> p3 . append ( vertex ( ( e , f ) ) ) <EOL> for i in range ( n ) : <EOL> Triangle = triangle ( p1 [ i ] , p2 [ i ] , p3 [ i ] ) <EOL> Circle = Triangle . circumscribed ( ) <EOL> print ( '<STR_LIT>' % ( Circle . px , Circle . py , Circle . r ) )
from math import cos , sin , sqrt , radians , degrees , acos , fabs <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> epsilon = <NUM_LIT> <EOL> num = int ( input ( ) ) <EOL> for i in range ( num ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = [ float ( x ) for x in input ( ) . split ( '<STR_LIT:U+0020>' ) ] <EOL> a = sqrt ( ( x1 - x2 ) ** <NUM_LIT:2> + ( y1 - y2 ) ** <NUM_LIT:2> ) <EOL> b = sqrt ( ( x2 - x3 ) ** <NUM_LIT:2> + ( y2 - y3 ) ** <NUM_LIT:2> ) <EOL> c = sqrt ( ( x1 - x3 ) ** <NUM_LIT:2> + ( y1 - y3 ) ** <NUM_LIT:2> ) <EOL> cosA = ( b ** <NUM_LIT:2> + c ** <NUM_LIT:2> - a ** <NUM_LIT:2> ) / ( <NUM_LIT:2> * b * c ) <EOL> r = a / sin ( acos ( cosA ) ) / <NUM_LIT:2> <EOL> """<STR_LIT>""" <EOL> A = - <NUM_LIT:2> * x1 + <NUM_LIT:2> * x2 <EOL> B = - <NUM_LIT:2> * y1 + <NUM_LIT:2> * y2 <EOL> C = - <NUM_LIT:2> * x1 + <NUM_LIT:2> * x3 <EOL> D = - <NUM_LIT:2> * y1 + <NUM_LIT:2> * y3 <EOL> E = x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> - x2 ** <NUM_LIT:2> - y2 ** <NUM_LIT:2> <EOL> F = x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> - x3 ** <NUM_LIT:2> - y3 ** <NUM_LIT:2> <EOL> x = <NUM_LIT:1> / ( A * D - B * C ) * ( D * E - B * F ) <EOL> y = <NUM_LIT:1> / ( A * D - B * C ) * ( - C * E + A * F ) <EOL> if fabs ( x ) < epsilon : <EOL> x = <NUM_LIT:0.0> <EOL> if fabs ( y ) < epsilon : <EOL> y = <NUM_LIT:0.0> <EOL> print ( '<STR_LIT>' . format ( - x , - y , r ) )
import sys <EOL> def prod_mat_vec ( A , vec ) : <EOL> ret = [ <NUM_LIT:0> for i in xrange ( <NUM_LIT:3> ) ] <EOL> for i in xrange ( <NUM_LIT:3> ) : <EOL> for j in xrange ( <NUM_LIT:3> ) : <EOL> ret [ i ] += A [ i ] [ j ] * vec [ j ] <EOL> return ret <EOL> def changerow ( A , i1 , i2 ) : <EOL> for j in xrange ( <NUM_LIT:3> ) : <EOL> buf = A [ i1 ] [ j ] <EOL> A [ i1 ] [ j ] = A [ i2 ] [ j ] <EOL> A [ i2 ] [ j ] = buf <EOL> return A <EOL> def MatrixInverse3x3 ( A_src ) : <EOL> A = [ [ A_src [ i ] [ j ] for j in xrange ( <NUM_LIT:3> ) ] for i in xrange ( <NUM_LIT:3> ) ] <EOL> B = [ [ <NUM_LIT:1> , <NUM_LIT:0> , <NUM_LIT:0> ] , [ <NUM_LIT:0> , <NUM_LIT:1> , <NUM_LIT:0> ] , [ <NUM_LIT:0> , <NUM_LIT:0> , <NUM_LIT:1> ] ] <EOL> for i in xrange ( <NUM_LIT:3> ) : <EOL> if A [ i ] [ i ] == <NUM_LIT:0> : <EOL> for k in xrange ( i + <NUM_LIT:1> , <NUM_LIT:3> ) : <EOL> if A [ k ] [ k ] != <NUM_LIT:0> : <EOL> A = changerow ( A , i , k ) <EOL> B = changerow ( B , i , k ) <EOL> a = A [ i ] [ i ] <EOL> for j in xrange ( <NUM_LIT:3> ) : <EOL> A [ i ] [ j ] /= a <EOL> B [ i ] [ j ] /= a <EOL> for k in xrange ( <NUM_LIT:3> ) : <EOL> if i == k : continue <EOL> a = A [ k ] [ i ] <EOL> for j in xrange ( <NUM_LIT:3> ) : <EOL> A [ k ] [ j ] -= A [ i ] [ j ] * a <EOL> B [ k ] [ j ] -= B [ i ] [ j ] * a <EOL> return B <EOL> def output3x3 ( A ) : <EOL> for i in xrange ( <NUM_LIT:3> ) : <EOL> print "<STR_LIT>" % ( A [ i ] [ <NUM_LIT:0> ] , A [ i ] [ <NUM_LIT:1> ] , A [ i ] [ <NUM_LIT:2> ] ) <EOL> return <EOL> for line in sys . stdin . readlines ( ) : <EOL> List = map ( float , line . strip ( ) . split ( ) ) <EOL> if len ( List ) == <NUM_LIT:1> : continue <EOL> [ x1 , y1 , x2 , y2 , x3 , y3 ] = List <EOL> A = [ [ x1 , y1 , <NUM_LIT:1.0> ] , [ x2 , y2 , <NUM_LIT:1.0> ] , [ x3 , y3 , <NUM_LIT:1.0> ] ] <EOL> vec = [ x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> , x2 ** <NUM_LIT:2> + y2 ** <NUM_LIT:2> , x3 ** <NUM_LIT:2> + y3 ** <NUM_LIT:2> ] <EOL> B = MatrixInverse3x3 ( A ) <EOL> lmn = prod_mat_vec ( B , vec ) <EOL> ans = [ <NUM_LIT:0.5> * lmn [ <NUM_LIT:0> ] , <NUM_LIT:0.5> * lmn [ <NUM_LIT:1> ] , ( lmn [ <NUM_LIT:2> ] + <NUM_LIT> * lmn [ <NUM_LIT:0> ] ** <NUM_LIT:2> + <NUM_LIT> * lmn [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) ** <NUM_LIT:0.5> ] <EOL> print "<STR_LIT>" % ( ans [ <NUM_LIT:0> ] , ans [ <NUM_LIT:1> ] , ans [ <NUM_LIT:2> ] )
import sys <EOL> import cmath <EOL> import math <EOL> class Point ( object ) : <EOL> def __init__ ( self , x , y ) : <EOL> self . point = complex ( x , y ) <EOL> def __str__ ( self ) : <EOL> return "<STR_LIT>" . format ( self . point . real , self . point . imag ) <EOL> class Triangle ( Point ) : <EOL> def __init__ ( self , a , b , c ) : <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> self . edgeA = abs ( b . point - c . point ) <EOL> self . edgeB = abs ( c . point - a . point ) <EOL> self . edgeC = abs ( a . point - b . point ) <EOL> self . angleA = Triangle . angle ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleB = Triangle . angle ( self . edgeB , self . edgeC , self . edgeA ) <EOL> self . angleC = Triangle . angle ( self . edgeC , self . edgeA , self . edgeB ) <EOL> def angle ( A , B , C ) : <EOL> return cmath . acos ( ( B * B + C * C - A * A ) / ( <NUM_LIT:2> * B * C ) ) . real <EOL> eps = <NUM_LIT> <EOL> for line in sys . stdin : <EOL> line = [ float ( x ) for x in line . split ( ) ] <EOL> p1 = Point ( line [ <NUM_LIT:0> ] , line [ <NUM_LIT:1> ] ) <EOL> p2 = Point ( line [ <NUM_LIT:2> ] , line [ <NUM_LIT:3> ] ) <EOL> p3 = Point ( line [ <NUM_LIT:4> ] , line [ <NUM_LIT:5> ] ) <EOL> P = Point ( line [ <NUM_LIT:6> ] , line [ <NUM_LIT:7> ] ) <EOL> t1 = Triangle ( p1 , p2 , P ) <EOL> t2 = Triangle ( p2 , p3 , P ) <EOL> t3 = Triangle ( p3 , p1 , P ) <EOL> if ( math . degrees ( t1 . angleC + t2 . angleC + t3 . angleC ) <= <NUM_LIT> + eps ) and ( math . degrees ( t1 . angleC + t2 . angleC + t3 . angleC ) >= <NUM_LIT> - eps ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" )
pap = [ [ <NUM_LIT:0> for x in range ( <NUM_LIT:10> ) ] for y in range ( <NUM_LIT:10> ) ] <EOL> def brot ( x , y , s ) : <EOL> if s == <NUM_LIT:1> : <EOL> for dx in range ( - <NUM_LIT:1> , + <NUM_LIT:1> + <NUM_LIT:1> ) : <EOL> for dy in range ( - <NUM_LIT:1> , + <NUM_LIT:1> + <NUM_LIT:1> ) : <EOL> px = x + dx <EOL> py = y + dy <EOL> if abs ( dx ) + abs ( dy ) < <NUM_LIT:2> and px in range ( <NUM_LIT:0> , <NUM_LIT:10> ) and py in range ( <NUM_LIT:0> , <NUM_LIT:10> ) : <EOL> pap [ py ] [ px ] += <NUM_LIT:1> <EOL> elif s == <NUM_LIT:2> : <EOL> for dx in range ( - <NUM_LIT:1> , + <NUM_LIT:1> + <NUM_LIT:1> ) : <EOL> for dy in range ( - <NUM_LIT:1> , + <NUM_LIT:1> + <NUM_LIT:1> ) : <EOL> px = x + dx <EOL> py = y + dy <EOL> if px in range ( <NUM_LIT:0> , <NUM_LIT:10> ) and py in range ( <NUM_LIT:0> , <NUM_LIT:10> ) : <EOL> pap [ py ] [ px ] += <NUM_LIT:1> <EOL> elif s == <NUM_LIT:3> : <EOL> for dx in range ( - <NUM_LIT:2> , + <NUM_LIT:2> + <NUM_LIT:1> ) : <EOL> for dy in range ( - <NUM_LIT:2> , + <NUM_LIT:2> + <NUM_LIT:1> ) : <EOL> px = x + dx <EOL> py = y + dy <EOL> if abs ( dx ) + abs ( dy ) < <NUM_LIT:3> and px in range ( <NUM_LIT:0> , <NUM_LIT:10> ) and py in range ( <NUM_LIT:0> , <NUM_LIT:10> ) : <EOL> pap [ py ] [ px ] += <NUM_LIT:1> <EOL> else : <EOL> raise ( ValueError ) <EOL> def ans ( ) : <EOL> bmax = <NUM_LIT:0> <EOL> wcount = <NUM_LIT:0> <EOL> for y in range ( <NUM_LIT:0> , + <NUM_LIT:9> + <NUM_LIT:1> ) : <EOL> for x in range ( <NUM_LIT:0> , + <NUM_LIT:9> + <NUM_LIT:1> ) : <EOL> b = pap [ y ] [ x ] <EOL> if b > bmax : <EOL> bmax = b <EOL> elif b == <NUM_LIT:0> : <EOL> wcount += <NUM_LIT:1> <EOL> return ( wcount , bmax ) <EOL> while True : <EOL> try : <EOL> x , y , s = list ( map ( int , input ( ) . split ( '<STR_LIT:U+002C>' ) ) ) <EOL> brot ( x , y , s ) <EOL> except EOFError : <EOL> break <EOL> print ( "<STR_LIT>" % ans ( ) )
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy <EOL> sys . setrecursionlimit ( <NUM_LIT:10> ** <NUM_LIT:7> ) <EOL> inf = <NUM_LIT:10> ** <NUM_LIT:20> <EOL> mod = <NUM_LIT:10> ** <NUM_LIT:9> + <NUM_LIT:7> <EOL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <EOL> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <EOL> def I ( ) : return int ( sys . stdin . readline ( ) ) <EOL> def F ( ) : return float ( sys . stdin . readline ( ) ) <EOL> def S ( ) : return input ( ) <EOL> class Matrix ( ) : <EOL> def __init__ ( self , A ) : <EOL> self . A = A <EOL> self . row = len ( A ) <EOL> self . col = len ( A [ <NUM_LIT:0> ] ) <EOL> def __iter__ ( self ) : <EOL> return self . A . __iter__ ( ) <EOL> def __getitem__ ( self , i ) : <EOL> return self . A . __getitem__ ( i ) <EOL> def __add__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> return Matrix ( [ [ aa [ i ] [ j ] + bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <EOL> def __sub__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> return Matrix ( [ [ aa [ i ] [ j ] - bb [ i ] [ j ] for j in range ( self . col ) ] for i in range ( self . row ) ] ) <EOL> def __mul__ ( self , B ) : <EOL> aa = self . A <EOL> bb = B . A <EOL> a = [ ] <EOL> for i in range ( self . row ) : <EOL> ai = aa [ i ] <EOL> r = [ ] <EOL> for j in range ( B . col ) : <EOL> r . append ( sum ( [ ai [ k ] * bb [ k ] [ j ] for k in range ( self . col ) ] ) ) <EOL> a . append ( r ) <EOL> return Matrix ( a ) <EOL> def __truediv__ ( self , x ) : <EOL> pass <EOL> def lu ( self ) : <EOL> size = self . row <EOL> T = copy . deepcopy ( self . A ) <EOL> L = [ [ <NUM_LIT:0> ] * size for _ in range ( size ) ] <EOL> U = [ [ <NUM_LIT:0> ] * size for _ in range ( size ) ] <EOL> for i in range ( size ) : <EOL> for j in range ( i , size ) : <EOL> L [ j ] [ i ] = T [ j ] [ i ] <EOL> for j in range ( i , size ) : <EOL> U [ i ] [ j ] = T [ i ] [ j ] / T [ i ] [ i ] <EOL> for j in range ( i + <NUM_LIT:1> , size ) : <EOL> for k in range ( i + <NUM_LIT:1> , size ) : <EOL> T [ j ] [ k ] -= L [ j ] [ i ] * U [ i ] [ k ] <EOL> return Matrix ( L ) , Matrix ( U ) <EOL> def __str__ ( self ) : <EOL> return self . A . __str__ ( ) <EOL> def solve_se ( A , b ) : <EOL> n = A . row <EOL> L , U = A . lu ( ) <EOL> y = [ ] <EOL> for i in range ( n ) : <EOL> t = b [ i ] <EOL> for k in range ( i ) : <EOL> t -= L [ i ] [ k ] * y [ k ] <EOL> y . append ( t / L [ i ] [ i ] ) <EOL> x = [ <NUM_LIT:0> ] * n <EOL> for i in range ( n - <NUM_LIT:1> , - <NUM_LIT:1> , - <NUM_LIT:1> ) : <EOL> t = y [ i ] <EOL> for k in range ( i + <NUM_LIT:1> , n ) : <EOL> t -= U [ i ] [ k ] * x [ k ] <EOL> x [ i ] = t <EOL> return x <EOL> def main ( ) : <EOL> sa = [ s for s in sys . stdin . read ( ) . split ( '<STR_LIT:\n>' ) if s ] <EOL> r = [ ] <EOL> for s in sa : <EOL> a , b , c , d , e , f = [ int ( c ) for c in s . split ( ) ] <EOL> A = Matrix ( [ [ a , b ] , [ d , e ] ] ) <EOL> B = [ c , f ] <EOL> x = solve_se ( A , B ) <EOL> r . append ( '<STR_LIT:U+0020>' . join ( map ( lambda t : '<STR_LIT>' . format ( <NUM_LIT:1.0> * t ) , x ) ) ) <EOL> return '<STR_LIT:\n>' . join ( r ) <EOL> print ( main ( ) )
import sys <EOL> MAX = <NUM_LIT> <EOL> L = [ <NUM_LIT:2> , <NUM_LIT:3> , <NUM_LIT:5> , <NUM_LIT:7> , <NUM_LIT:11> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> def is_prime ( n ) : <EOL> if n == <NUM_LIT:2> : return True <EOL> if n % <NUM_LIT:2> == <NUM_LIT:0> : return False <EOL> for i in range ( <NUM_LIT:3> , int ( n ** <NUM_LIT:0.5> ) + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if n % i == <NUM_LIT:0> : return False <EOL> return True <EOL> def is_prime_2 ( n ) : <EOL> a = int ( n ** <NUM_LIT:0.5> ) <EOL> for i in L : <EOL> if i > a : return True <EOL> if n % i == <NUM_LIT:0> : return False <EOL> return True <EOL> def prime_count ( n ) : <EOL> result = <NUM_LIT:0> <EOL> if n >= <NUM_LIT:2> : result += <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:3> , n + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if is_prime_2 ( i ) : result += <NUM_LIT:1> <EOL> return result <EOL> def prime_list ( n ) : <EOL> result = [ ] <EOL> if n >= <NUM_LIT:2> : result . append ( <NUM_LIT:2> ) <EOL> for i in range ( <NUM_LIT:3> , n + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if is_prime ( i ) : result . append ( i ) <EOL> return result <EOL> L2 = prime_list ( MAX ) <EOL> def prime_count_2 ( n ) : <EOL> for i , v in enumerate ( L2 ) : <EOL> if v > n : return i <EOL> return len ( L2 ) <EOL> for n in sys . stdin : <EOL> print ( prime_count_2 ( int ( n ) ) )
import sys <EOL> import math <EOL> prim_no = { <NUM_LIT:2> : True } <EOL> def is_prime ( no ) : <EOL> if no == <NUM_LIT:2> or no == <NUM_LIT:1> : <EOL> return True <EOL> if no % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> return False <EOL> if prim_no . get ( no ) is not None : <EOL> return prim_no . get ( no ) <EOL> max_check = int ( math . sqrt ( no ) ) <EOL> for i in range ( <NUM_LIT:3> , max_check + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if no % i == <NUM_LIT:0> : <EOL> prim_no [ no ] = False <EOL> return False <EOL> prim_no [ no ] = True <EOL> return True <EOL> def main ( ) : <EOL> prim_vals = { } <EOL> while True : <EOL> num = sys . stdin . readline ( ) <EOL> if num is None or num . strip ( ) == '<STR_LIT>' : <EOL> break <EOL> num = int ( num . strip ( ) ) <EOL> if prim_vals . get ( num ) is not None : <EOL> cnt = prim_vals . get ( num ) <EOL> else : <EOL> if num == <NUM_LIT:1> : <EOL> cnt = <NUM_LIT:0> <EOL> else : <EOL> cnt = <NUM_LIT:0> <EOL> if num % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> start_num = num - <NUM_LIT:1> <EOL> else : <EOL> start_num = num <EOL> for i in range ( start_num , <NUM_LIT:0> , - <NUM_LIT:2> ) : <EOL> if prim_vals . get ( i ) is not None : <EOL> cnt += prim_vals . get ( i ) <EOL> break <EOL> if is_prime ( i ) : <EOL> cnt += <NUM_LIT:1> <EOL> prim_vals [ num ] = cnt <EOL> print ( cnt ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> def norm2d ( vec ) : <EOL> return ( vec [ <NUM_LIT:0> ] ** <NUM_LIT:2> + vec [ <NUM_LIT:1> ] ** <NUM_LIT:2> ) ** <NUM_LIT:0.5> <EOL> def normalize ( vec ) : <EOL> l = norm2d ( vec ) <EOL> vec [ <NUM_LIT:0> ] /= l <EOL> vec [ <NUM_LIT:1> ] /= l <EOL> return vec <EOL> lineNumber = <NUM_LIT:0> <EOL> for line in sys . stdin . readlines ( ) : <EOL> lineNumber += <NUM_LIT:1> <EOL> if lineNumber == <NUM_LIT:1> : continue <EOL> List = map ( float , line . strip ( ) . split ( "<STR_LIT:U+0020>" ) ) <EOL> a = [ List [ <NUM_LIT:0> ] , List [ <NUM_LIT:1> ] ] <EOL> b = [ List [ <NUM_LIT:2> ] , List [ <NUM_LIT:3> ] ] <EOL> c = [ List [ <NUM_LIT:4> ] , List [ <NUM_LIT:5> ] ] <EOL> d = [ List [ <NUM_LIT:6> ] , List [ <NUM_LIT:7> ] ] <EOL> vec1 = [ a [ <NUM_LIT:0> ] - b [ <NUM_LIT:0> ] , a [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] ] <EOL> vec2 = [ c [ <NUM_LIT:0> ] - d [ <NUM_LIT:0> ] , c [ <NUM_LIT:1> ] - d [ <NUM_LIT:1> ] ] <EOL> if vec1 [ <NUM_LIT:0> ] < <NUM_LIT:0> : <EOL> vec1 [ <NUM_LIT:0> ] *= - <NUM_LIT:1> <EOL> vec1 [ <NUM_LIT:1> ] *= - <NUM_LIT:1> <EOL> if vec2 [ <NUM_LIT:0> ] < <NUM_LIT:0> : <EOL> vec2 [ <NUM_LIT:0> ] *= - <NUM_LIT:1> <EOL> vec2 [ <NUM_LIT:1> ] *= - <NUM_LIT:1> <EOL> vec1 = normalize ( vec1 ) <EOL> vec2 = normalize ( vec2 ) <EOL> if abs ( vec1 [ <NUM_LIT:0> ] - vec2 [ <NUM_LIT:0> ] ) < <NUM_LIT:10> ** ( - <NUM_LIT:10> ) and abs ( vec1 [ <NUM_LIT:1> ] - vec2 [ <NUM_LIT:1> ] ) < <NUM_LIT:10> ** ( - <NUM_LIT:10> ) : <EOL> print "<STR_LIT>" <EOL> else : <EOL> print "<STR_LIT>"
def main ( ) : <EOL> N = int ( input ( ) ) <EOL> for _ in range ( N ) : <EOL> n1 = input ( ) . strip ( ) <EOL> n2 = input ( ) . strip ( ) <EOL> if len ( n1 ) > <NUM_LIT> or len ( n2 ) > <NUM_LIT> : <EOL> print ( "<STR_LIT>" ) <EOL> continue <EOL> print ( add ( n1 , n2 ) ) <EOL> return <EOL> def add ( n1 , n2 ) : <EOL> """<STR_LIT>""" <EOL> kotae = "<STR_LIT>" <EOL> n1 = n1 [ : : - <NUM_LIT:1> ] <EOL> n2 = n2 [ : : - <NUM_LIT:1> ] <EOL> if len ( n1 ) < len ( n2 ) : <EOL> n1 , n2 = n2 , n1 <EOL> shorter = min ( len ( n1 ) , len ( n2 ) ) <EOL> longer = max ( len ( n1 ) , len ( n2 ) ) <EOL> idx , kuriagari = <NUM_LIT:0> , <NUM_LIT:0> <EOL> while idx < longer : <EOL> if idx >= shorter : <EOL> tmp = int ( n1 [ idx ] ) + kuriagari <EOL> kuriagari = <NUM_LIT:1> if tmp >= <NUM_LIT:10> else <NUM_LIT:0> <EOL> kotae += str ( tmp ) [ - <NUM_LIT:1> ] <EOL> idx += <NUM_LIT:1> <EOL> while idx < shorter : <EOL> tmp = int ( n1 [ idx ] ) + int ( n2 [ idx ] ) + kuriagari <EOL> kuriagari = <NUM_LIT:1> if tmp >= <NUM_LIT:10> else <NUM_LIT:0> <EOL> kotae += str ( tmp ) [ - <NUM_LIT:1> ] <EOL> idx += <NUM_LIT:1> <EOL> if kuriagari : <EOL> kotae += "<STR_LIT:1>" <EOL> if len ( kotae ) > <NUM_LIT> : <EOL> return "<STR_LIT>" <EOL> else : <EOL> return kotae [ : : - <NUM_LIT:1> ] <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( )
A = [ [ int ( <NUM_LIT:0> ) for i in range ( <NUM_LIT:10> ) ] for j in range ( <NUM_LIT:10> ) ] <EOL> count = <NUM_LIT:0> <EOL> while <NUM_LIT:1> : <EOL> try : <EOL> x , y , s = map ( int , input ( ) . split ( '<STR_LIT:U+002C>' ) ) <EOL> if s == <NUM_LIT:1> : <EOL> for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ i ] [ y ] = A [ i ] [ y ] + <NUM_LIT:1> <EOL> for i in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ x ] [ i ] = A [ x ] [ i ] + <NUM_LIT:1> <EOL> A [ x ] [ y ] = A [ x ] [ y ] - <NUM_LIT:1> <EOL> elif s == <NUM_LIT:2> : <EOL> for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) : <EOL> for j in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> and j >= <NUM_LIT:0> and j <= <NUM_LIT:9> : <EOL> A [ i ] [ j ] = A [ i ] [ j ] + <NUM_LIT:1> <EOL> else : <EOL> for i in range ( x - <NUM_LIT:2> , x + <NUM_LIT:3> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ i ] [ y ] = A [ i ] [ y ] + <NUM_LIT:1> <EOL> for i in range ( y - <NUM_LIT:2> , y + <NUM_LIT:3> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ x ] [ i ] = A [ x ] [ i ] + <NUM_LIT:1> <EOL> for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ i ] [ y ] = A [ i ] [ y ] - <NUM_LIT:1> <EOL> for i in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> : <EOL> A [ x ] [ i ] = A [ x ] [ i ] - <NUM_LIT:1> <EOL> for i in range ( x - <NUM_LIT:1> , x + <NUM_LIT:2> ) : <EOL> for j in range ( y - <NUM_LIT:1> , y + <NUM_LIT:2> ) : <EOL> if i >= <NUM_LIT:0> and i <= <NUM_LIT:9> and j >= <NUM_LIT:0> and j <= <NUM_LIT:9> : <EOL> A [ i ] [ j ] = A [ i ] [ j ] + <NUM_LIT:1> <EOL> except : <EOL> break <EOL> num = <NUM_LIT:0> <EOL> for i in range ( <NUM_LIT:10> ) : <EOL> for j in range ( <NUM_LIT:10> ) : <EOL> if A [ i ] [ j ] == <NUM_LIT:0> : <EOL> count = count + <NUM_LIT:1> <EOL> if A [ i ] [ j ] != <NUM_LIT:0> : <EOL> if num < A [ i ] [ j ] : <EOL> num = A [ i ] [ j ] <EOL> print ( count ) <EOL> print ( num )
import sys <EOL> import math <EOL> import array <EOL> class mymath : <EOL> pi = <NUM_LIT> <EOL> def pnum_eratosthenes ( self , n ) : <EOL> ptable = [ <NUM_LIT:0> for i in range ( n + <NUM_LIT:1> ) ] <EOL> plist = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if ptable [ i ] == <NUM_LIT:0> : <EOL> plist . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> ptable [ j ] = <NUM_LIT:1> <EOL> return plist <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> def mul ( self , A , B ) : <EOL> ans = [ ] <EOL> for a in A : <EOL> c = <NUM_LIT:0> <EOL> for j , row in enumerate ( a ) : <EOL> c += row * B [ j ] <EOL> ans . append ( c ) <EOL> return ans <EOL> mymath = mymath ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> def main ( ) : <EOL> W = int ( input ( ) ) <EOL> N = int ( input ( ) ) <EOL> AB = [ [ int ( x ) - <NUM_LIT:1> for x in input ( ) . split ( '<STR_LIT:U+002C>' ) ] for i in range ( N ) ] <EOL> ans = list ( range ( <NUM_LIT:1> , W + <NUM_LIT:1> ) ) <EOL> for ab in AB : <EOL> ans [ ab [ <NUM_LIT:0> ] ] , ans [ ab [ <NUM_LIT:1> ] ] = ans [ ab [ <NUM_LIT:1> ] ] , ans [ ab [ <NUM_LIT:0> ] ] <EOL> for i in ans : <EOL> print ( i ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> import math <EOL> class mymath : <EOL> pi = <NUM_LIT> <EOL> def pnum_eratosthenes ( self , n ) : <EOL> ptable = [ <NUM_LIT:0> for i in range ( n + <NUM_LIT:1> ) ] <EOL> plist = [ ] <EOL> for i in range ( <NUM_LIT:2> , n + <NUM_LIT:1> ) : <EOL> if ptable [ i ] == <NUM_LIT:0> : <EOL> plist . append ( i ) <EOL> for j in range ( i + i , n + <NUM_LIT:1> , i ) : <EOL> ptable [ j ] = <NUM_LIT:1> <EOL> return plist <EOL> def pnum_check ( self , n ) : <EOL> if ( n == <NUM_LIT:1> ) : <EOL> return False <EOL> elif ( n == <NUM_LIT:2> ) : <EOL> return True <EOL> else : <EOL> for x in range ( <NUM_LIT:2> , n ) : <EOL> if ( n % x == <NUM_LIT:0> ) : <EOL> return False <EOL> return True <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> def mul ( self , A , B ) : <EOL> ans = [ ] <EOL> for a in A : <EOL> c = <NUM_LIT:0> <EOL> for j , row in enumerate ( a ) : <EOL> c += row * B [ j ] <EOL> ans . append ( c ) <EOL> return ans <EOL> def is_integer ( self , n ) : <EOL> try : <EOL> float ( n ) <EOL> except ValueError : <EOL> return False <EOL> else : <EOL> return float ( n ) . is_integer ( ) <EOL> def dist ( self , A , B ) : <EOL> d = <NUM_LIT:0> <EOL> for i in range ( len ( A ) ) : <EOL> d += ( A [ i ] - B [ i ] ) ** <NUM_LIT:2> <EOL> d = d ** ( <NUM_LIT:1> / <NUM_LIT:2> ) <EOL> return d <EOL> def abs ( self , n ) : <EOL> if n >= <NUM_LIT:0> : <EOL> return n <EOL> else : <EOL> return - n <EOL> mymath = mymath ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> def printA ( A ) : <EOL> N = len ( A ) <EOL> for i , n in enumerate ( A ) : <EOL> print ( n , end = '<STR_LIT>' ) <EOL> if i != N - <NUM_LIT:1> : <EOL> print ( '<STR_LIT:U+0020>' , end = '<STR_LIT>' ) <EOL> print ( ) <EOL> def get_input ( ) : <EOL> N = [ ] <EOL> while True : <EOL> try : <EOL> N . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <EOL> except EOFError : <EOL> break <EOL> return N <EOL> n = int ( input ( ) ) <EOL> ans = <NUM_LIT:1> <EOL> for i in range ( <NUM_LIT:1> , n + <NUM_LIT:1> ) : <EOL> ans *= i <EOL> print ( ans )
import math <EOL> def calc_digit ( data1 , data2 ) : <EOL> if ( data1 == <NUM_LIT:0> ) : <EOL> data_size2 = int ( len ( str ( data2 ) ) ) <EOL> data_size1 = <NUM_LIT:1> <EOL> elif ( data2 == <NUM_LIT:0> ) : <EOL> data_size1 = int ( len ( str ( data2 ) ) ) <EOL> data_size2 = <NUM_LIT:1> <EOL> else : <EOL> data_size1 = int ( len ( str ( data1 ) ) ) <EOL> data_size2 = int ( len ( str ( data2 ) ) ) <EOL> return ( data_size1 , data_size2 ) <EOL> def two_number_sum ( data1 , data2 ) : <EOL> result = data1 + data2 <EOL> if int ( len ( str ( result ) ) ) > <NUM_LIT> : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( result ) <EOL> def main ( ) : <EOL> a = [ ] <EOL> N = int ( input ( ) ) <EOL> for i in range ( N * <NUM_LIT:2> ) : <EOL> a . append ( input ( ) ) <EOL> for i in range ( <NUM_LIT:0> , N * <NUM_LIT:2> ) : <EOL> if i % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> continue <EOL> else : <EOL> data1 = int ( a [ i - <NUM_LIT:1> ] ) <EOL> data2 = int ( a [ i ] ) <EOL> if ( data1 == None ) : <EOL> data1 = <NUM_LIT:0> <EOL> elif ( data2 == None ) : <EOL> data2 = <NUM_LIT:0> <EOL> x , y = calc_digit ( data1 , data2 ) <EOL> if ( x > <NUM_LIT> or y > <NUM_LIT> ) : <EOL> print ( "<STR_LIT>" ) <EOL> continue <EOL> two_number_sum ( data1 , data2 ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import math <EOL> PI = math . pi <EOL> EPS = <NUM_LIT:10> ** - <NUM_LIT:10> <EOL> def edge ( a , b ) : <EOL> return ( ( a [ <NUM_LIT:0> ] - b [ <NUM_LIT:0> ] ) ** <NUM_LIT:2> + ( a [ <NUM_LIT:1> ] - b [ <NUM_LIT:1> ] ) ** <NUM_LIT:2> ) ** <NUM_LIT> <EOL> def area ( a , b , c ) : <EOL> s = ( a + b + c ) / <NUM_LIT:2> <EOL> return ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** <NUM_LIT> <EOL> def LawOfCosines ( a , b , c ) : <EOL> return math . acos ( ( b * b + c * c - a * a ) / ( <NUM_LIT> * b * c ) ) ; <EOL> def is_same ( x , y ) : <EOL> return abs ( x - y ) < EPS <EOL> class Triangle : <EOL> def __init__ ( self , p ) : <EOL> a , b , c = p <EOL> self . a = a <EOL> self . b = b <EOL> self . c = c <EOL> self . edgeA = edge ( b , c ) <EOL> self . edgeB = edge ( c , a ) <EOL> self . edgeC = edge ( a , b ) <EOL> self . area = area ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleA = LawOfCosines ( self . edgeA , self . edgeB , self . edgeC ) <EOL> self . angleB = LawOfCosines ( self . edgeB , self . edgeC , self . edgeA ) <EOL> self . angleC = LawOfCosines ( self . edgeC , self . edgeA , self . edgeB ) <EOL> def circumscribeadCircleRadius ( self ) : <EOL> return self . edgeA / math . sin ( self . angleA ) / <NUM_LIT> <EOL> def circumscribedCircleCenter ( self ) : <EOL> a = math . sin ( <NUM_LIT> * self . angleA ) ; <EOL> b = math . sin ( <NUM_LIT> * self . angleB ) ; <EOL> c = math . sin ( <NUM_LIT> * self . angleC ) ; <EOL> X = ( self . a [ <NUM_LIT:0> ] * a + self . b [ <NUM_LIT:0> ] * b + self . c [ <NUM_LIT:0> ] * c ) / ( a + b + c ) ; <EOL> Y = ( self . a [ <NUM_LIT:1> ] * a + self . b [ <NUM_LIT:1> ] * b + self . c [ <NUM_LIT:1> ] * c ) / ( a + b + c ) ; <EOL> return X , Y <EOL> def inscribedCircleRadius ( self ) : <EOL> return <NUM_LIT:2> * self . area / ( self . edgeA + self . edgeB + self . edgeC ) <EOL> def inscribedCircleCenter ( self ) : <EOL> points = [ self . a , self . b , self . c ] <EOL> edges = [ self . edgeA , self . edgeB , self . edgeC ] <EOL> s = sum ( edges ) <EOL> return [ sum ( [ points [ j ] [ i ] * edges [ j ] for j in range ( <NUM_LIT:3> ) ] ) / s for i in range ( <NUM_LIT:2> ) ] <EOL> def isInner ( self , p ) : <EOL> cross = lambda a , b : a [ <NUM_LIT:0> ] * b [ <NUM_LIT:1> ] - a [ <NUM_LIT:1> ] * b [ <NUM_LIT:0> ] <EOL> c1 = <NUM_LIT:0> <EOL> c2 = <NUM_LIT:0> <EOL> points = [ self . a , self . b , self . c ] <EOL> for i in range ( <NUM_LIT:3> ) : <EOL> a = [ points [ i ] [ <NUM_LIT:0> ] - points [ ( i + <NUM_LIT:1> ) % <NUM_LIT:3> ] [ <NUM_LIT:0> ] , points [ i ] [ <NUM_LIT:1> ] - points [ ( i + <NUM_LIT:1> ) % <NUM_LIT:3> ] [ <NUM_LIT:1> ] ] <EOL> b = [ points [ i ] [ <NUM_LIT:0> ] - p [ <NUM_LIT:0> ] , points [ i ] [ <NUM_LIT:1> ] - p [ <NUM_LIT:1> ] ] <EOL> c = cross ( a , b ) <EOL> if c > <NUM_LIT:0> : <EOL> c1 += <NUM_LIT:1> <EOL> elif c < <NUM_LIT:0> : <EOL> c2 += <NUM_LIT:1> <EOL> if c1 == <NUM_LIT:3> or c2 == <NUM_LIT:3> : <EOL> return True <EOL> else : <EOL> return c1 + c2 != <NUM_LIT:3> and ( c1 == <NUM_LIT:0> or c2 == <NUM_LIT:0> ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> while True : <EOL> try : <EOL> c = list ( map ( float , input ( ) . split ( ) ) ) <EOL> points = [ ( c [ i ] , c [ i + <NUM_LIT:1> ] ) for i in range ( <NUM_LIT:0> , <NUM_LIT:6> , <NUM_LIT:2> ) ] <EOL> point = [ c [ <NUM_LIT:6> ] , c [ <NUM_LIT:7> ] ] <EOL> t = Triangle ( points ) <EOL> print ( [ "<STR_LIT>" , "<STR_LIT>" ] [ t . isInner ( point ) ] ) <EOL> except : <EOL> break
while True : <EOL> try : <EOL> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <EOL> xg = <NUM_LIT:1.> / <NUM_LIT:3> * ( x1 + x2 + x3 ) <EOL> yg = <NUM_LIT:1.> / <NUM_LIT:3> * ( y1 + y2 + y3 ) <EOL> def line ( xi , yi , xj , yj , x , y ) : <EOL> return ( yi - yj ) * x / ( xi - xj ) + ( xi * yj - xj * yi ) / ( xi - xj ) <EOL> if x1 != x2 : <EOL> def line12 ( x , y ) : <EOL> if y < line ( x1 , y1 , x2 , y2 , x , y ) : <EOL> return <NUM_LIT:2> <EOL> elif y > line ( x1 , y1 , x2 , y2 , x , y ) : <EOL> return <NUM_LIT:3> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> else : <EOL> def line12 ( x , y ) : <EOL> if x1 < x : <EOL> return <NUM_LIT:2> <EOL> elif x1 > x : <EOL> return <NUM_LIT:3> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> if x2 != x3 : <EOL> def line23 ( x , y ) : <EOL> if y < line ( x2 , y2 , x3 , y3 , x , y ) : <EOL> return <NUM_LIT:5> <EOL> elif y > line ( x2 , y2 , x3 , y3 , x , y ) : <EOL> return <NUM_LIT:7> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> else : <EOL> def line23 ( x , y ) : <EOL> if x2 < x : <EOL> return <NUM_LIT:5> <EOL> elif x2 > x : <EOL> return <NUM_LIT:7> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> if x1 != x3 : <EOL> def line13 ( x , y ) : <EOL> if y < line ( x1 , y1 , x3 , y3 , x , y ) : <EOL> return <NUM_LIT:11> <EOL> elif y > line ( x1 , y1 , x3 , y3 , x , y ) : <EOL> return <NUM_LIT> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> else : <EOL> def line13 ( x , y ) : <EOL> if x1 < x : <EOL> return <NUM_LIT:11> <EOL> elif x1 > x : <EOL> return <NUM_LIT> <EOL> else : <EOL> return <NUM_LIT:0> <EOL> if line12 ( xp , yp ) * line23 ( xp , yp ) * line13 ( xp , yp ) == line12 ( xg , yg ) * line23 ( xg , yg ) * line13 ( xg , yg ) : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" ) <EOL> except EOFError : <EOL> break
from math import sqrt , fabs <EOL> def calcu_cirucumcenter ( x1 , y1 , x2 , y2 , x3 , y3 ) : <EOL> """<STR_LIT>""" <EOL> a = - <NUM_LIT:2> * x1 + <NUM_LIT:2> * x2 <EOL> b = - <NUM_LIT:2> * y1 + <NUM_LIT:2> * y2 <EOL> c = - <NUM_LIT:2> * x1 + <NUM_LIT:2> * x3 <EOL> d = - <NUM_LIT:2> * y1 + <NUM_LIT:2> * y3 <EOL> e = - <NUM_LIT:1> * ( x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> - x2 ** <NUM_LIT:2> - y2 ** <NUM_LIT:2> ) <EOL> f = - <NUM_LIT:1> * ( x1 ** <NUM_LIT:2> + y1 ** <NUM_LIT:2> - x3 ** <NUM_LIT:2> - y3 ** <NUM_LIT:2> ) <EOL> x = <NUM_LIT:1> / ( a * d - b * c ) * ( d * e - b * f ) <EOL> y = <NUM_LIT:1> / ( a * d - b * c ) * ( - c * e + a * f ) <EOL> return x , y <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> epsilon = <NUM_LIT> <EOL> num = int ( input ( ) ) <EOL> for i in range ( num ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = [ float ( x ) for x in input ( ) . split ( '<STR_LIT:U+0020>' ) ] <EOL> x , y = calcu_cirucumcenter ( x1 , y1 , x2 , y2 , x3 , y3 ) <EOL> if fabs ( x ) < epsilon : <EOL> x = <NUM_LIT:0.0> <EOL> if fabs ( y ) < epsilon : <EOL> y = <NUM_LIT:0.0> <EOL> r = sqrt ( ( x - x1 ) ** <NUM_LIT:2> + ( y - y1 ) ** <NUM_LIT:2> ) <EOL> print ( '<STR_LIT>' . format ( x , y , r ) )
class Paper : <EOL> def __init__ ( self , x , y ) : <EOL> self . A = [ [ <NUM_LIT:0> for i in range ( x ) ] for j in range ( y ) ] <EOL> self . size = ( x , y ) <EOL> def drop ( self , x , y , s ) : <EOL> if s == <NUM_LIT:1> : <EOL> if y + <NUM_LIT:1> <= self . size [ <NUM_LIT:1> ] - <NUM_LIT:1> : <EOL> self . A [ y + <NUM_LIT:1> ] [ x ] += <NUM_LIT:1> <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y ] [ i ] += <NUM_LIT:1> <EOL> if y - <NUM_LIT:1> >= <NUM_LIT:0> : <EOL> self . A [ y - <NUM_LIT:1> ] [ x ] += <NUM_LIT:1> <EOL> if s == <NUM_LIT:2> : <EOL> if y + <NUM_LIT:1> <= self . size [ <NUM_LIT:1> ] - <NUM_LIT:1> : <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y + <NUM_LIT:1> ] [ i ] += <NUM_LIT:1> <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y ] [ i ] += <NUM_LIT:1> <EOL> if y - <NUM_LIT:1> >= <NUM_LIT:0> : <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y - <NUM_LIT:1> ] [ i ] += <NUM_LIT:1> <EOL> if s == <NUM_LIT:3> : <EOL> if y + <NUM_LIT:2> <= self . size [ <NUM_LIT:1> ] - <NUM_LIT:1> : <EOL> self . A [ y + <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> if y + <NUM_LIT:1> <= self . size [ <NUM_LIT:1> ] - <NUM_LIT:1> : <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y + <NUM_LIT:1> ] [ i ] += <NUM_LIT:1> <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:2> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:2> ) ) : <EOL> self . A [ y ] [ i ] += <NUM_LIT:1> <EOL> if y - <NUM_LIT:1> >= <NUM_LIT:0> : <EOL> for i in range ( max ( <NUM_LIT:0> , x - <NUM_LIT:1> ) , <NUM_LIT:1> + min ( self . size [ <NUM_LIT:0> ] - <NUM_LIT:1> , x + <NUM_LIT:1> ) ) : <EOL> self . A [ y - <NUM_LIT:1> ] [ i ] += <NUM_LIT:1> <EOL> if y - <NUM_LIT:2> >= <NUM_LIT:0> : <EOL> self . A [ y - <NUM_LIT:2> ] [ x ] += <NUM_LIT:1> <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> import sys <EOL> p = Paper ( <NUM_LIT:10> , <NUM_LIT:10> ) <EOL> L = sys . stdin . readlines ( ) <EOL> for l in L : <EOL> x , y , s = map ( int , l . split ( '<STR_LIT:U+002C>' ) ) <EOL> p . drop ( x , y , s ) <EOL> temp = [ ] <EOL> for y in p . A : <EOL> temp . extend ( y ) <EOL> A1 = temp . count ( <NUM_LIT:0> ) <EOL> A2 = max ( temp ) <EOL> print ( A1 ) <EOL> print ( A2 )
import sys <EOL> import math <EOL> prim_no = { <NUM_LIT:2> : True } <EOL> def is_prime ( no ) : <EOL> if no == <NUM_LIT:2> or no == <NUM_LIT:1> : <EOL> return True <EOL> if no % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> return False <EOL> if prim_no . get ( no ) is not None : <EOL> return prim_no . get ( no ) <EOL> max_check = int ( math . sqrt ( no ) ) <EOL> for i in range ( <NUM_LIT:3> , max_check + <NUM_LIT:1> , <NUM_LIT:2> ) : <EOL> if no % i == <NUM_LIT:0> : <EOL> prim_no [ no ] = False <EOL> return False <EOL> prim_no [ no ] = True <EOL> return True <EOL> def main ( ) : <EOL> prim_vals = { } <EOL> num_data = [ ] <EOL> while True : <EOL> num = sys . stdin . readline ( ) <EOL> if num is None or num . strip ( ) == '<STR_LIT>' : <EOL> break <EOL> num = int ( num . strip ( ) ) <EOL> num_data . append ( num ) <EOL> sorted_num_data = sorted ( num_data ) <EOL> prim_num = { } <EOL> for num in sorted_num_data : <EOL> if prim_vals . get ( num ) is not None : <EOL> cnt = prim_vals . get ( num ) <EOL> else : <EOL> if num == <NUM_LIT:1> : <EOL> cnt = <NUM_LIT:0> <EOL> else : <EOL> cnt = <NUM_LIT:0> <EOL> if num % <NUM_LIT:2> == <NUM_LIT:0> : <EOL> start_num = num - <NUM_LIT:1> <EOL> else : <EOL> start_num = num <EOL> for i in range ( start_num , <NUM_LIT:0> , - <NUM_LIT:2> ) : <EOL> if prim_vals . get ( i ) is not None : <EOL> cnt += prim_vals . get ( i ) <EOL> break <EOL> if is_prime ( i ) : <EOL> cnt += <NUM_LIT:1> <EOL> prim_vals [ num ] = cnt <EOL> prim_num [ num ] = cnt <EOL> for num in num_data : <EOL> print ( prim_num [ num ] ) <EOL> if __name__ == '<STR_LIT:__main__>' : <EOL> main ( )
import sys <EOL> class math : <EOL> pi = <NUM_LIT> <EOL> def gcd ( self , a , b ) : <EOL> if b == <NUM_LIT:0> : <EOL> return a <EOL> return self . gcd ( b , a % b ) <EOL> def lcm ( self , a , b ) : <EOL> return ( a * b ) // self . gcd ( a , b ) <EOL> math = math ( ) <EOL> class output : <EOL> def list ( self , l ) : <EOL> l = list ( l ) <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> for i , num in enumerate ( l ) : <EOL> print ( num , end = "<STR_LIT>" ) <EOL> if i != len ( l ) - <NUM_LIT:1> : <EOL> print ( "<STR_LIT:U+0020>" , end = "<STR_LIT>" ) <EOL> print ( ) <EOL> output = output ( ) <EOL> m = <NUM_LIT> <EOL> for i in range ( int ( input ( ) ) ) : <EOL> m *= <NUM_LIT> <EOL> if m % <NUM_LIT:1000> != <NUM_LIT:0> : <EOL> m = ( m // <NUM_LIT:1000> + <NUM_LIT:1> ) * <NUM_LIT:1000> <EOL> else : <EOL> m = ( m // <NUM_LIT:1000> ) * <NUM_LIT:1000> <EOL> print ( int ( m ) )
from math import * <EOL> def g ( x ) : <EOL> y = ( int ( ( <NUM_LIT:1000> * abs ( x ) ) * <NUM_LIT:2> + <NUM_LIT:1> ) // <NUM_LIT:2> ) / <NUM_LIT:1000> <EOL> if x < <NUM_LIT:0> : <EOL> y *= - <NUM_LIT:1> <EOL> return y <EOL> '''<STR_LIT>''' <EOL> def f ( x ) : <EOL> x1 , y1 , x2 , y2 , x3 , y3 = x <EOL> X1 = x1 - x3 <EOL> Y1 = y1 - y3 <EOL> X2 = x2 - x3 <EOL> Y2 = y2 - y3 <EOL> k = ( X2 ** <NUM_LIT:2> + Y2 ** <NUM_LIT:2> - X1 * X2 - Y1 * Y2 ) / ( <NUM_LIT:2> * ( X2 * Y1 - X1 * Y2 ) ) <EOL> X = X1 / <NUM_LIT:2> + k * Y1 + x3 <EOL> Y = Y1 / <NUM_LIT:2> - k * X1 + y3 <EOL> R = sqrt ( ( X - x1 ) ** <NUM_LIT:2> + ( Y - y1 ) ** <NUM_LIT:2> ) <EOL> X = g ( X ) <EOL> Y = g ( Y ) <EOL> R = g ( R ) <EOL> print ( "<STR_LIT>" . format ( X , Y , R ) ) <EOL> n = int ( input ( ) ) <EOL> a = [ ] <EOL> for _ in range ( n ) : <EOL> a . append ( list ( ( map ( float , input ( ) . split ( ) ) ) ) ) <EOL> for i in a : <EOL> f ( i )
import collections <EOL> import math <EOL> LIMIT = <NUM_LIT> <EOL> class Vector2 ( collections . namedtuple ( "<STR_LIT>" , "<STR_LIT>" ) ) : <EOL> __slots__ = ( ) <EOL> def __add__ ( self , other ) : <EOL> return Vector2 ( self . x + other . x , self . y + other . y ) <EOL> def __sub__ ( self , other ) : <EOL> return Vector2 ( self . x - other . x , self . y - other . y ) <EOL> def __mul__ ( self , other ) : <EOL> return self . x * other . y - self . y * other . x <EOL> def __neg__ ( self ) : <EOL> return Vector2 ( - self . x , - self . y ) <EOL> def __pos__ ( self ) : <EOL> return Vector2 ( + self . x , + self . y ) <EOL> def __abs__ ( self ) : <EOL> return math . sqrt ( float ( self . x * self . x + self . y * self . y ) ) <EOL> def dotproduct ( self , other ) : <EOL> return self . x * other . x + self . y * other . y <EOL> def main ( ) : <EOL> n = int ( input ( ) ) <EOL> for i in range ( n ) : <EOL> [ x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ] = [ float ( z ) for z in input ( ) . split ( ) ] <EOL> vector_ab = Vector2 ( x2 - x1 , y2 - y1 ) <EOL> vector_cd = Vector2 ( x4 - x3 , y4 - y3 ) <EOL> if abs ( vector_ab * vector_cd ) < LIMIT : <EOL> print ( "<STR_LIT>" ) <EOL> else : <EOL> print ( "<STR_LIT>" ) <EOL> if __name__ == "<STR_LIT:__main__>" : <EOL> main ( )
